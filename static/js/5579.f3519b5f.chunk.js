"use strict";(globalThis.webpackChunkimaps_app=globalThis.webpackChunkimaps_app||[]).push([[5579],{45028:(e,t,i)=>{i.d(t,{C:()=>S,b:()=>y});var r=i(22357),s=i(37081),n=i(33280),o=i(94951),a=i(14801),l=i(48655),c=i(16574),h=i(137),p=i(15226),d=i(26461),u=i(116),f=i(82552),g=i(95276),v=i(98634),m=i(64201),_=i(25920),T=i(4760);function y(e){const t=new m.kG,{vertex:i,fragment:y}=t,S=e.output===s.H.Depth,O=e.hasMultipassTerrain&&(e.output===s.H.Color||e.output===s.H.Alpha);return(0,f.Sv)(i,e),t.include(o.w,e),t.include(l.c,e),t.include(a.R,e),t.attributes.add(T.T.POSITION,"vec3"),t.varyings.add("vpos","vec3"),O&&t.varyings.add("depth","float"),S&&(t.include(c.F,e),(0,r.Zu)(t),(0,r.Lm)(t)),i.code.add(v.H`
    void main(void) {
      vpos = position;
      forwardNormalizedVertexColor();
      forwardObjectAndLayerIdColor();
      ${O?"depth = (view * vec4(vpos, 1.0)).z;":""}
      gl_Position = ${S?v.H`transformPositionWithDepth(proj, view, vpos, nearFar, linearDepth);`:v.H`transformPosition(proj, view, vpos);`}
    }
  `),t.include(n.f5,e),O&&t.include(p.l,e),y.include(u.Y),y.uniforms.add(new g.N("eColor",(e=>e.color))),e.output===s.H.Highlight&&t.include(h.bA,e),y.code.add(v.H`
  void main() {
    discardBySlice(vpos);
    ${O?"terrainDepthTest(gl_FragCoord, depth);":""}
    vec4 fColor = ${e.hasVertexColors?"vColor * eColor;":"eColor;"}

    if (fColor.a < ${v.H.float(d.b)}) {
      discard;
    }

    ${e.output===s.H.Alpha?v.H`gl_FragColor = vec4(fColor.a);`:""}

    ${e.output===s.H.Color?v.H`gl_FragColor = highlightSlice(fColor, vpos); ${e.transparencyPassType===_.A.Color?"gl_FragColor = premultiplyAlpha(gl_FragColor);":""}`:""}
    ${e.output===s.H.Highlight?v.H`outputHighlight();`:""};
    ${e.output===s.H.Depth?v.H`outputDepth(linearDepth);`:""};
    ${e.output===s.H.ObjectAndLayerIdColor?v.H`outputObjectAndLayerIdColor();`:""}
  }
  `),t}const S=Object.freeze(Object.defineProperty({__proto__:null,build:y},Symbol.toStringTag,{value:"Module"}))},99337:(e,t,i)=>{i.d(t,{N:()=>m,b:()=>v});var r=i(37081),s=i(33280),n=i(94951),o=i(48655),a=i(137),l=i(60300),c=i(26461),h=i(82552),p=i(95276),d=i(58406),u=i(98634),f=i(64201),g=i(4760);function v(e){const t=new f.kG,{vertex:i,fragment:v}=t;return t.include(n.w,e),t.include(o.c,e),t.include(l.q,e),(0,h.Sv)(i,e),e.stippleEnabled&&(t.attributes.add(g.T.UV0,"vec2"),t.attributes.add(g.T.AUXPOS1,"vec3"),i.uniforms.add(new p.N("viewport",((e,t)=>t.camera.fullViewport)))),t.attributes.add(g.T.POSITION,"vec3"),t.varyings.add("vpos","vec3"),i.code.add(u.H`void main(void) {
vpos = position;
forwardNormalizedVertexColor();
gl_Position = transformPosition(proj, view, vpos);`),e.stippleEnabled&&(i.code.add(u.H`vec4 vpos2 = transformPosition(proj, view, auxpos1);
vec2 ndcToPixel = viewport.zw * 0.5;
float lineSegmentPixelSize = length((vpos2.xy / vpos2.w - gl_Position.xy / gl_Position.w) * ndcToPixel);`),e.draped?i.uniforms.add(new d.p("worldToScreenRatio",((e,t)=>1/t.screenToPCSRatio))):i.code.add(u.H`vec3 segmentCenter = (position + auxpos1) * 0.5;
float worldToScreenRatio = computeWorldToScreenRatio(segmentCenter);`),i.code.add(u.H`float discreteWorldToScreenRatio = discretizeWorldToScreenRatio(worldToScreenRatio);`),e.draped?i.code.add(u.H`float startPseudoScreen = uv0.y * discreteWorldToScreenRatio - mix(0.0, lineSegmentPixelSize, uv0.x);
float segmentLengthPseudoScreen = lineSegmentPixelSize;`):i.code.add(u.H`float segmentLengthRender = length(position - auxpos1);
float startPseudoScreen = mix(uv0.y, uv0.y - segmentLengthRender, uv0.x) * discreteWorldToScreenRatio;
float segmentLengthPseudoScreen = segmentLengthRender * discreteWorldToScreenRatio;`),i.uniforms.add(new d.p("stipplePatternPixelSize",(e=>(0,l.C)(e)))),i.code.add(u.H`vec2 stippleDistanceLimits = computeStippleDistanceLimits(startPseudoScreen, segmentLengthPseudoScreen, lineSegmentPixelSize, stipplePatternPixelSize);
vStippleDistance = mix(stippleDistanceLimits.x, stippleDistanceLimits.y, uv0.x);
vStippleDistance *= gl_Position.w;`)),i.code.add(u.H`}`),e.output===r.H.Highlight&&t.include(a.bA,e),t.include(s.f5,e),v.uniforms.add(new d.p("alphaCoverage",((e,t)=>Math.min(1,e.width*t.camera.pixelRatio)))),e.hasVertexColors||v.uniforms.add(new p.N("constantColor",(e=>e.color))),v.code.add(u.H`
  void main() {
    discardBySlice(vpos);

    vec4 color = ${e.hasVertexColors?"vColor":"constantColor"};

    float stippleAlpha = getStippleAlpha();
    discardByStippleAlpha(stippleAlpha, stippleAlphaColorDiscard);

    vec4 finalColor = blendStipple(vec4(color.rgb, color.a * alphaCoverage), stippleAlpha);

    if (finalColor.a < ${u.H.float(c.b)}) {
      discard;
    }

    ${e.output===r.H.Color?u.H`gl_FragColor = highlightSlice(finalColor, vpos);`:""}
    ${e.output===r.H.Highlight?u.H`outputHighlight();`:""}
  }
  `),t}const m=Object.freeze(Object.defineProperty({__proto__:null,build:v},Symbol.toStringTag,{value:"Module"}))},98186:(e,t,i)=>{i.d(t,{N:()=>P,R:()=>C,b:()=>R});var r=i(92026),s=i(22357),n=i(37081),o=i(33280),a=i(14801),l=i(48353),c=i(16574),h=i(60300),p=i(40526),d=i(15226),u=i(85586),f=i(26461),g=i(116),v=i(82552),m=i(82999),_=i(95276),T=i(58406),y=i(98634),S=i(8654),O=i(64201),b=i(25920),A=i(4760),x=i(33720),w=i(737);const P=1;function R(e){const t=new O.kG,{vertex:i,fragment:R}=t,C=e.hasMultipassTerrain&&(e.output===n.H.Color||e.output===n.H.Alpha);t.include(u.e),t.include(l.U,e),t.include(h.q,e);const D=e.applyMarkerOffset&&!e.draped;D&&(i.uniforms.add(new T.p("markerScale",(e=>e.markerScale))),t.include(p.Q,{space:x.I9.World})),e.output===n.H.Depth&&t.include(c.F,e),t.include(a.R,e),(0,v.Sv)(i,e),i.uniforms.add([new S.g("inverseProjectionMatrix",((e,t)=>t.camera.inverseProjectionMatrix)),new m.A("nearFar",((e,t)=>t.camera.nearFar)),new T.p("miterLimit",(e=>"miter"!==e.join?0:e.miterLimit)),new _.N("viewport",((e,t)=>t.camera.fullViewport))]),i.constants.add("LARGE_HALF_FLOAT","float",65500),t.attributes.add(A.T.POSITION,"vec3"),t.attributes.add(A.T.SUBDIVISIONFACTOR,"float"),t.attributes.add(A.T.UV0,"vec2"),t.attributes.add(A.T.AUXPOS1,"vec3"),t.attributes.add(A.T.AUXPOS2,"vec3"),t.varyings.add("vColor","vec4"),t.varyings.add("vpos","vec3"),(0,s.Lm)(t),C&&t.varyings.add("depth","float");const L=e.capType===w.R.ROUND,M=e.stippleEnabled&&e.stippleScaleWithLineWidth||L;M&&t.varyings.add("vLineWidth","float");const E=e.stippleEnabled&&e.stippleScaleWithLineWidth;E&&t.varyings.add("vLineSizeInv","float");const I=e.innerColorEnabled||L;I&&t.varyings.add("vLineDistance","float");const N=e.stippleEnabled&&L,j=e.falloffEnabled||N;j&&t.varyings.add("vLineDistanceNorm","float"),L&&(t.varyings.add("vSegmentSDF","float"),t.varyings.add("vReverseSegmentSDF","float")),i.code.add(y.H`#define PERPENDICULAR(v) vec2(v.y, -v.x);
float interp(float ncp, vec4 a, vec4 b) {
return (-ncp - a.z) / (b.z - a.z);
}
vec2 rotate(vec2 v, float a) {
float s = sin(a);
float c = cos(a);
mat2 m = mat2(c, -s, s, c);
return m * v;
}`),i.code.add(y.H`vec4 projectAndScale(vec4 pos) {
vec4 posNdc = proj * pos;
posNdc.xy *= viewport.zw / posNdc.w;
return posNdc;
}`),(0,s.bA)(t),i.code.add(y.H`
    void clipAndTransform(inout vec4 pos, inout vec4 prev, inout vec4 next, in bool isStartVertex) {
      float vnp = nearFar[0] * 0.99;

      if(pos.z > -nearFar[0]) {
        //current pos behind ncp --> we need to clip
        if (!isStartVertex) {
          if(prev.z < -nearFar[0]) {
            //previous in front of ncp
            pos = mix(prev, pos, interp(vnp, prev, pos));
            next = pos;
          } else {
            pos = vec4(0.0, 0.0, 0.0, 1.0);
          }
        } else {
          if(next.z < -nearFar[0]) {
            //next in front of ncp
            pos = mix(pos, next, interp(vnp, pos, next));
            prev = pos;
          } else {
            pos = vec4(0.0, 0.0, 0.0, 1.0);
          }
        }
      } else {
        //current position visible
        if (prev.z > -nearFar[0]) {
          //previous behind ncp
          prev = mix(pos, prev, interp(vnp, pos, prev));
        }
        if (next.z > -nearFar[0]) {
          //next behind ncp
          next = mix(next, pos, interp(vnp, next, pos));
        }
      }

      ${C?"depth = pos.z;":""}
      linearDepth = calculateLinearDepth(nearFar,pos.z);

      pos = projectAndScale(pos);
      next = projectAndScale(next);
      prev = projectAndScale(prev);
    }
  `),i.uniforms.add(new T.p("pixelRatio",((e,t)=>t.camera.pixelRatio))),i.code.add(y.H`
  void main(void) {
    // unpack values from uv0.y
    bool isStartVertex = abs(abs(uv0.y)-3.0) == 1.0;

    float coverage = 1.0;

    // Check for special value of uv0.y which is used by the Renderer when graphics
    // are removed before the VBO is recompacted. If this is the case, then we just
    // project outside of clip space.
    if (uv0.y == 0.0) {
      // Project out of clip space
      gl_Position = vec4(1e038, 1e038, 1e038, 1.0);
    }
    else {
      bool isJoin = abs(uv0.y) < 3.0;

      float lineSize = getSize();
      float lineWidth = lineSize * pixelRatio;

      ${M?y.H`vLineWidth = lineWidth;`:""}
      ${E?y.H`vLineSizeInv = 1.0 / lineSize;`:""}

      // convert sub-pixel coverage to alpha
      if (lineWidth < 1.0) {
        coverage = lineWidth;
        lineWidth = 1.0;
      }else{
        // Ribbon lines cannot properly render non-integer sizes. Round width to integer size if
        // larger than one for better quality. Note that we do render < 1 pixels more or less correctly
        // so we only really care to round anything larger than 1.
        lineWidth = floor(lineWidth + 0.5);
      }

      vec4 pos  = view * vec4(position.xyz, 1.0);
      vec4 prev = view * vec4(auxpos1.xyz, 1.0);
      vec4 next = view * vec4(auxpos2.xyz, 1.0);
  `),D&&i.code.add(y.H`vec4 other = isStartVertex ? next : prev;
bool markersHidden = areWorldMarkersHidden(pos, other);
if(!isJoin && !markersHidden) {
pos.xyz += normalize(other.xyz - pos.xyz) * getWorldMarkerSize(pos) * 0.5;
}`),i.code.add(y.H`clipAndTransform(pos, prev, next, isStartVertex);
vec2 left = (pos.xy - prev.xy);
vec2 right = (next.xy - pos.xy);
float leftLen = length(left);
float rightLen = length(right);`),(e.stippleEnabled||L)&&i.code.add(y.H`
      float isEndVertex = float(!isStartVertex);
      vec2 segmentOrigin = mix(pos.xy, prev.xy, isEndVertex);
      vec2 segment = mix(right, left, isEndVertex);
      ${L?y.H`vec2 segmentEnd = mix(next.xy, pos.xy, isEndVertex);`:""}
    `),i.code.add(y.H`left = (leftLen > 0.001) ? left/leftLen : vec2(0.0, 0.0);
right = (rightLen > 0.001) ? right/rightLen : vec2(0.0, 0.0);
vec2 capDisplacementDir = vec2(0, 0);
vec2 joinDisplacementDir = vec2(0, 0);
float displacementLen = lineWidth;
if (isJoin) {
bool isOutside = (left.x * right.y - left.y * right.x) * uv0.y > 0.0;
joinDisplacementDir = normalize(left + right);
joinDisplacementDir = PERPENDICULAR(joinDisplacementDir);
if (leftLen > 0.001 && rightLen > 0.001) {
float nDotSeg = dot(joinDisplacementDir, left);
displacementLen /= length(nDotSeg * left - joinDisplacementDir);
if (!isOutside) {
displacementLen = min(displacementLen, min(leftLen, rightLen)/abs(nDotSeg));
}
}
if (isOutside && (displacementLen > miterLimit * lineWidth)) {`),e.roundJoins?i.code.add(y.H`
        vec2 startDir = leftLen < 0.001 ? right : left;
        startDir = PERPENDICULAR(startDir);

        vec2 endDir = rightLen < 0.001 ? left : right;
        endDir = PERPENDICULAR(endDir);

        float factor = ${e.stippleEnabled?y.H`min(1.0, subdivisionFactor * ${y.H.float((P+2)/(P+1))})`:y.H`subdivisionFactor`};

        float rotationAngle = acos(clamp(dot(startDir, endDir), -1.0, 1.0));
        joinDisplacementDir = rotate(startDir, -sign(uv0.y) * factor * rotationAngle);
      `):i.code.add(y.H`if (leftLen < 0.001) {
joinDisplacementDir = right;
}
else if (rightLen < 0.001) {
joinDisplacementDir = left;
}
else {
joinDisplacementDir = (isStartVertex || subdivisionFactor > 0.0) ? right : left;
}
joinDisplacementDir = PERPENDICULAR(joinDisplacementDir);`);const H=e.capType!==w.R.BUTT;return i.code.add(y.H`
        displacementLen = lineWidth;
      }
    } else {
      // CAP handling ---------------------------------------------------
      joinDisplacementDir = isStartVertex ? right : left;
      joinDisplacementDir = PERPENDICULAR(joinDisplacementDir);

      ${H?y.H`capDisplacementDir = isStartVertex ? -right : left;`:""}
    }
  `),i.code.add(y.H`
    // Displacement (in pixels) caused by join/or cap
    vec2 dpos = joinDisplacementDir * sign(uv0.y) * displacementLen + capDisplacementDir * displacementLen;

    ${j||I?y.H`float lineDistNorm = sign(uv0.y) * pos.w;`:""}

    ${I?y.H`vLineDistance = lineWidth * lineDistNorm;`:""}
    ${j?y.H`vLineDistanceNorm = lineDistNorm;`:""}

    pos.xy += dpos;
  `),L&&i.code.add(y.H`vec2 segmentDir = normalize(segment);
vSegmentSDF = (isJoin && isStartVertex) ? LARGE_HALF_FLOAT : (dot(pos.xy - segmentOrigin, segmentDir) * pos.w) ;
vReverseSegmentSDF = (isJoin && !isStartVertex) ? LARGE_HALF_FLOAT : (dot(pos.xy - segmentEnd, -segmentDir) * pos.w);`),e.stippleEnabled&&(e.draped?i.uniforms.add(new T.p("worldToScreenRatio",((e,t)=>1/t.screenToPCSRatio))):i.code.add(y.H`vec3 segmentCenter = mix((auxpos2 + position) * 0.5, (position + auxpos1) * 0.5, isEndVertex);
float worldToScreenRatio = computeWorldToScreenRatio(segmentCenter);`),i.code.add(y.H`float segmentLengthScreenDouble = length(segment);
float segmentLengthScreen = segmentLengthScreenDouble * 0.5;
float discreteWorldToScreenRatio = discretizeWorldToScreenRatio(worldToScreenRatio);
float segmentLengthRender = length(mix(auxpos2 - position, position - auxpos1, isEndVertex));
vStipplePatternStretch = worldToScreenRatio / discreteWorldToScreenRatio;`),e.draped?i.code.add(y.H`float segmentLengthPseudoScreen = segmentLengthScreen / pixelRatio * discreteWorldToScreenRatio / worldToScreenRatio;
float startPseudoScreen = uv0.x * discreteWorldToScreenRatio - mix(0.0, segmentLengthPseudoScreen, isEndVertex);`):i.code.add(y.H`float startPseudoScreen = mix(uv0.x, uv0.x - segmentLengthRender, isEndVertex) * discreteWorldToScreenRatio;
float segmentLengthPseudoScreen = segmentLengthRender * discreteWorldToScreenRatio;`),i.uniforms.add(new T.p("stipplePatternPixelSize",(e=>(0,h.C)(e)))),i.code.add(y.H`
      float patternLength = ${e.stippleScaleWithLineWidth?"lineSize * ":""} stipplePatternPixelSize;

      // Compute the coordinates at both start and end of the line segment, because we need both to clamp to in the fragment shader
      vStippleDistanceLimits = computeStippleDistanceLimits(startPseudoScreen, segmentLengthPseudoScreen, segmentLengthScreen, patternLength);

      vStippleDistance = mix(vStippleDistanceLimits.x, vStippleDistanceLimits.y, isEndVertex);

      // Adjust the coordinate to the displaced position (the pattern is shortened/overextended on the in/outside of joins)
      if (segmentLengthScreenDouble >= 0.001) {
        // Project the actual vertex position onto the line segment. Note that the resulting factor is within [0..1] at the
        // original vertex positions, and slightly outside of that range at the displaced positions
        vec2 stippleDisplacement = pos.xy - segmentOrigin;
        float stippleDisplacementFactor = dot(segment, stippleDisplacement) / (segmentLengthScreenDouble * segmentLengthScreenDouble);

        // Apply this offset to the actual vertex coordinate (can be screen or pseudo-screen space)
        vStippleDistance += (stippleDisplacementFactor - isEndVertex) * (vStippleDistanceLimits.y - vStippleDistanceLimits.x);
      }

      // Cancel out perspective correct interpolation because we want this length the really represent the screen distance
      vStippleDistanceLimits *= pos.w;
      vStippleDistance *= pos.w;

      // Disable stipple distance limits on caps
      vStippleDistanceLimits = isJoin ?
                                 vStippleDistanceLimits :
                                 isStartVertex ?
                                  vec2(-1e038, vStippleDistanceLimits.y) :
                                  vec2(vStippleDistanceLimits.x, 1e038);
    `)),i.code.add(y.H`
      // Convert back into NDC
      pos.xy = (pos.xy / viewport.zw) * pos.w;

      vColor = getColor();
      vColor.a *= coverage;

      ${e.wireframe&&!e.draped?"pos.z -= 0.001 * pos.w;":""}

      // transform final position to camera space for slicing
      vpos = (inverseProjectionMatrix * pos).xyz;
      gl_Position = pos;
      forwardObjectAndLayerIdColor();
    }
  }
  `),C&&t.include(d.l,e),t.include(o.f5,e),R.include(g.Y),R.code.add(y.H`
  void main() {
    discardBySlice(vpos);
    ${C?"terrainDepthTest(gl_FragCoord, depth);":""}
  `),e.wireframe?R.code.add(y.H`vec4 finalColor = vec4(1.0, 0.0, 1.0, 1.0);`):(L&&R.code.add(y.H`
      float sdf = min(vSegmentSDF, vReverseSegmentSDF);
      vec2 fragmentPosition = vec2(
        min(sdf, 0.0),
        vLineDistance
      ) * gl_FragCoord.w;

      float fragmentRadius = length(fragmentPosition);
      float fragmentCapSDF = (fragmentRadius - vLineWidth) * 0.5; // Divide by 2 to transform from double pixel scale
      float capCoverage = clamp(0.5 - fragmentCapSDF, 0.0, 1.0);

      if (capCoverage < ${y.H.float(f.b)}) {
        discard;
      }
    `),N?R.code.add(y.H`
      vec2 stipplePosition = vec2(
        min(getStippleSDF() * 2.0 - 1.0, 0.0),
        vLineDistanceNorm * gl_FragCoord.w
      );
      float stippleRadius = length(stipplePosition * vLineWidth);
      float stippleCapSDF = (stippleRadius - vLineWidth) * 0.5; // Divide by 2 to transform from double pixel scale
      float stippleCoverage = clamp(0.5 - stippleCapSDF, 0.0, 1.0);
      float stippleAlpha = step(${y.H.float(f.b)}, stippleCoverage);
      `):R.code.add(y.H`float stippleAlpha = getStippleAlpha();`),R.uniforms.add(new _.N("intrinsicColor",(e=>e.color))),R.code.add(y.H`discardByStippleAlpha(stippleAlpha, stippleAlphaColorDiscard);
vec4 color = intrinsicColor * vColor;`),e.innerColorEnabled&&(R.uniforms.add(new _.N("innerColor",(e=>(0,r.Pt)(e.innerColor,e.color)))),R.uniforms.add(new T.p("innerWidth",((e,t)=>e.innerWidth*t.camera.pixelRatio))),R.code.add(y.H`float distToInner = abs(vLineDistance * gl_FragCoord.w) - innerWidth;
float innerAA = clamp(0.5 - distToInner, 0.0, 1.0);
float innerAlpha = innerColor.a + color.a * (1.0 - innerColor.a);
color = mix(color, vec4(innerColor.rgb, innerAlpha), innerAA);`)),R.code.add(y.H`vec4 finalColor = blendStipple(color, stippleAlpha);`),e.falloffEnabled&&(R.uniforms.add(new T.p("falloff",(e=>e.falloff))),R.code.add(y.H`finalColor.a *= pow(max(0.0, 1.0 - abs(vLineDistanceNorm * gl_FragCoord.w)), falloff);`))),R.code.add(y.H`
    if (finalColor.a < ${y.H.float(f.b)}) {
      discard;
    }

    ${e.output===n.H.Alpha?y.H`gl_FragColor = vec4(finalColor.a);`:""}
    ${e.output===n.H.Color?y.H`gl_FragColor = highlightSlice(finalColor, vpos);`:""}
    ${e.output===n.H.Color&&e.transparencyPassType===b.A.Color?"gl_FragColor = premultiplyAlpha(gl_FragColor);":""}
    ${e.output===n.H.Highlight?y.H`gl_FragColor = vec4(1.0);`:""}
    ${e.output===n.H.Depth?y.H`outputDepth(linearDepth);`:""}
    ${e.output===n.H.ObjectAndLayerIdColor?y.H`outputObjectAndLayerIdColor();`:""}
  }
  `),t}const C=Object.freeze(Object.defineProperty({__proto__:null,NUM_ROUND_JOIN_SUBDIVISIONS:P,build:R},Symbol.toStringTag,{value:"Module"}))},82218:(e,t,i)=>{i.d(t,{a:()=>m,c:()=>_,g:()=>O,h:()=>C,u:()=>y});i(93169);var r=i(32718),s=i(16889),n=i(21530),o=i(14226),a=i(81949),l=i(11186),c=i(71353),h=i(14320),p=i(85981),d=i(55652),u=i(40885),f=i(40927),g=i(11185);const v=r.Z.getLogger("esri.views.3d.support.geometryUtils.boundedPlane");function m(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:H;return{plane:(0,d.Ue)(e.plane),origin:(0,c.a)(e.origin),basis1:(0,c.a)(e.basis1),basis2:(0,c.a)(e.basis2)}}function _(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:m();return T(e.origin,e.basis1,e.basis2,t)}function T(e,t,i){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:m();return(0,l.c)(r.origin,e),(0,l.c)(r.basis1,t),(0,l.c)(r.basis2,i),y(r),N(r,"fromValues()"),r}function y(e){(0,d.my)(e.basis2,e.basis1,e.origin,e.plane)}function S(e,t,i){e!==i&&_(e,i);const r=(0,l.g)(g.WM.get(),L(e),t);return(0,l.a)(i.origin,i.origin,r),i.plane[3]-=t,i}function O(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:m();const i=(e[2]-e[0])/2,r=(e[3]-e[1])/2;return(0,l.s)(t.origin,e[0]+i,e[1]+r,0),(0,l.s)(t.basis1,i,0,0),(0,l.s)(t.basis2,0,r,0),(0,d.al)(0,0,1,0,t.plane),t}function b(e,t,i){return!!(0,d.BR)(e.plane,t,i)&&M(e,i)}function A(e,t,i){const r=F.get();j(e,t,r,F.get());let n=Number.POSITIVE_INFINITY;for(const o of W){const a=I(e,o,U.get()),c=g.WM.get();if((0,d.rx)(r,a,c)){const e=(0,l.r)(g.WM.get(),t.origin,c),r=Math.abs((0,s.ZF)((0,l.e)(t.direction,e)));r<n&&(n=r,(0,l.c)(i,c))}}return n===Number.POSITIVE_INFINITY?x(e,t,i):i}function x(e,t,i){if(b(e,t,i))return i;const r=F.get(),s=F.get();j(e,t,r,s);let n=Number.POSITIVE_INFINITY;for(const o of W){const a=I(e,o,U.get()),c=g.WM.get();if((0,d.dZ)(r,a,c)){const e=(0,u.Jk)(t,c);if(!(0,d.Ac)(s,c))continue;e<n&&(n=e,(0,l.c)(i,c))}}return R(e,t.origin)<n&&w(e,t.origin,i),i}function w(e,t,i){const r=(0,d.nF)(e.plane,t,g.WM.get()),s=(0,p.ct)(E(e,e.basis1),r,-1,1,g.WM.get()),n=(0,p.ct)(E(e,e.basis2),r,-1,1,g.WM.get());return(0,l.b)(i,(0,l.a)(g.WM.get(),s,n),e.origin),i}function P(e,t,i){const{origin:r,basis1:s,basis2:n}=e,o=(0,l.b)(g.WM.get(),t,r),a=(0,f.SR)(s,o),c=(0,f.SR)(n,o),h=(0,f.SR)(L(e),o);return(0,l.s)(i,a,c,h)}function R(e,t){const i=P(e,t,g.WM.get()),{basis1:r,basis2:s}=e,n=(0,l.l)(r),o=(0,l.l)(s),a=Math.max(Math.abs(i[0])-n,0),c=Math.max(Math.abs(i[1])-o,0),h=i[2];return a*a+c*c+h*h}function C(e,t){return Math.sqrt(R(e,t))}function D(e,t){const i=-e.plane[3];return(0,f.SR)(L(e),t)-i}function L(e){return(0,d.mJ)(e.plane)}function M(e,t){const i=(0,l.b)(g.WM.get(),t,e.origin),r=(0,l.p)(e.basis1),s=(0,l.p)(e.basis2),n=(0,l.e)(e.basis1,i),o=(0,l.e)(e.basis2,i);return-n-r<0&&n-r<0&&-o-s<0&&o-s<0}function E(e,t){const i=U.get();return(0,l.c)(i.origin,e.origin),(0,l.c)(i.vector,t),i}function I(e,t,i){const{basis1:r,basis2:s,origin:n}=e,o=(0,l.g)(g.WM.get(),r,t.origin[0]),a=(0,l.g)(g.WM.get(),s,t.origin[1]);(0,l.a)(i.origin,o,a),(0,l.a)(i.origin,i.origin,n);const c=(0,l.g)(g.WM.get(),r,t.direction[0]),h=(0,l.g)(g.WM.get(),s,t.direction[1]);return(0,l.g)(i.vector,(0,l.a)(c,c,h),2),i}function N(e,t){Math.abs((0,l.e)(e.basis1,e.basis2)/((0,l.l)(e.basis1)*(0,l.l)(e.basis2)))>1e-6&&v.warn(t,"Provided basis vectors are not perpendicular"),Math.abs((0,l.e)(e.basis1,L(e)))>1e-6&&v.warn(t,"Basis vectors and plane normal are not perpendicular"),Math.abs(-(0,l.e)(L(e),e.origin)-e.plane[3])>1e-6&&v.warn(t,"Plane offset is not consistent with plane origin")}function j(e,t,i,r){const s=L(e);(0,d.my)(s,t.direction,t.origin,i),(0,d.my)((0,d.mJ)(i),s,t.origin,r)}const H={plane:(0,d.Ue)(),origin:(0,c.f)(0,0,0),basis1:(0,c.f)(1,0,0),basis2:(0,c.f)(0,1,0)},F=new n.x(d.Ue),U=new n.x(p.Ue),z=(0,c.c)(),V=new n.x((()=>m())),W=[{origin:[-1,-1],direction:[1,0]},{origin:[1,-1],direction:[0,1]},{origin:[1,1],direction:[-1,0]},{origin:[-1,1],direction:[0,-1]}],B=(0,a.c)(),G=(0,a.c)();Object.freeze(Object.defineProperty({__proto__:null,BoundedPlaneClass:class{constructor(){this.plane=(0,d.Ue)(),this.origin=(0,c.c)(),this.basis1=(0,c.c)(),this.basis2=(0,c.c)()}},create:m,wrap:function(e,t,i){const r=V.get();return r.origin=e,r.basis1=t,r.basis2=i,r.plane=(0,d.re)(0,0,0,0),y(r),r},copy:_,copyWithoutVerify:function(e,t){(0,l.c)(t.origin,e.origin),(0,l.c)(t.basis1,e.basis1),(0,l.c)(t.basis2,e.basis2),(0,d.JG)(t.plane,e.plane)},fromValues:T,updateUnboundedPlane:y,elevate:S,setExtent:function(e,t,i){return O(t,i),S(i,D(e,e.origin),i),i},fromAABoundingRect:O,intersectRay:b,intersectRayClosestSilhouette:function(e,t,i){if(b(e,t,i))return i;const r=A(e,t,g.WM.get());return(0,l.a)(i,t.origin,(0,l.g)(g.WM.get(),t.direction,(0,l.i)(t.origin,r)/(0,l.l)(t.direction))),i},closestPointOnSilhouette:A,closestPoint:x,projectPoint:w,projectPointLocal:P,distance2:R,distance:C,distanceToSilhouette:function(e,t){let i=Number.NEGATIVE_INFINITY;for(const r of W){const s=I(e,r,U.get()),n=(0,p.Jk)(s,t);n>i&&(i=n)}return Math.sqrt(i)},extrusionContainsPoint:function(e,t){return(0,d.Ac)(e.plane,t)&&M(e,t)},axisAt:function(e,t,i,r){return function(e,t,i){switch(t){case h.R.X:(0,l.c)(i,e.basis1),(0,l.n)(i,i);break;case h.R.Y:(0,l.c)(i,e.basis2),(0,l.n)(i,i);break;case h.R.Z:(0,l.c)(i,L(e))}return i}(e,i,r)},altitudeAt:D,setAltitudeAt:function(e,t,i,r){const s=D(e,t),n=(0,l.g)(z,L(e),i-s);return(0,l.a)(r,t,n),r},equals:function(e,t){return(0,l.k)(e.basis1,t.basis1)&&(0,l.k)(e.basis2,t.basis2)&&(0,l.k)(e.origin,t.origin)},transform:function(e,t,i){return e!==i&&_(e,i),(0,o.a)(B,t),(0,o.t)(B,B),(0,l.m)(i.basis1,e.basis1,B),(0,l.m)(i.basis2,e.basis2,B),(0,l.m)((0,d.mJ)(i.plane),(0,d.mJ)(e.plane),B),(0,l.m)(i.origin,e.origin,t),(0,d.T5)(i.plane,i.plane,i.origin),i},rotate:function(e,t,i,r){return e!==r&&_(e,r),(0,o.d)(G,t,i),(0,l.m)(r.basis1,e.basis1,G),(0,l.m)(r.basis2,e.basis2,G),y(r),r},normal:L,UP:H},Symbol.toStringTag,{value:"Module"}))},46228:(e,t,i)=>{i.d(t,{I:()=>s,v:()=>n});var r=i(16889);function s(e,t){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const s=(0,r.uZ)(e,0,l);for(let r=0;r<4;r++)t[i+r]=Math.floor(256*c(s*o[r]))}function n(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,i=0;for(let r=0;r<4;r++)i+=e[t+r]*a[r];return i}const o=[1,256,65536,16777216],a=[1/256,1/65536,1/16777216,1/4294967296],l=n(new Uint8ClampedArray([255,255,255,255]));function c(e){return e-Math.floor(e)}},81020:(e,t,i)=>{function r(e){return"point"===e.type}i.d(t,{f:()=>r})},96387:(e,t,i)=>{i.d(t,{CV:()=>O,Go:()=>S,Si:()=>R,Uu:()=>b,ZL:()=>w,_Z:()=>P,bD:()=>A,bh:()=>x,zE:()=>_});var r=i(92026),s=i(68860),n=i(14226),o=i(81949),a=i(71353),l=i(90045),c=i(67077),h=i(79803),p=i(41414),d=i(65156),u=i(4954),f=i(69662),g=i(65618),v=i(37818),m=i(4760);function _(e,t){if("point"===e.type)return y(e,t,!1);if((0,v.Ou)(e))switch(e.type){case"extent":return y(e.center,t,!1);case"polygon":return y(e.centroid,t,!1);case"polyline":return y(T(e),t,!0);case"mesh":return y(e.origin,t,!1)}else switch(e.type){case"extent":return y(function(e){const t=isFinite(e.zmin);return(0,g.Tx)(.5*(e.xmax+e.xmin),.5*(e.ymax+e.ymin),t?.5*(e.zmax+e.zmin):void 0,e.spatialReference)}(e),t,!0);case"polygon":return y(function(e){const t=e.rings[0];if(!t||0===t.length)return null;const i=(0,u.a)(e.rings,e.hasZ);return(0,g.Tx)(i[0],i[1],i[2],e.spatialReference)}(e),t,!0);case"polyline":return y(T(e),t,!0)}}function T(e){const t=e.paths[0];if(!t||0===t.length)return null;const i=(0,f.n8)(t,(0,f.ok)(t)/2);return(0,g.Tx)(i[0],i[1],i[2],e.spatialReference)}function y(e,t,i){const r=i?e:(0,v.WG)(e);return t&&e?(0,h.nF)(e,r,t)?r:null:r}function S(e,t,i){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;if(e){t||(t=(0,d.Ue)());const s=e;let n=.5*s.width*(i-1),o=.5*s.height*(i-1);return s.width<1e-7*s.height?n+=o/20:s.height<1e-7*s.width&&(o+=n/20),(0,l.s)(t,s.xmin-n-r,s.ymin-o-r,s.xmax+n+r,s.ymax+o+r),t}return null}function O(e,t){for(let i=0;i<e.geometries.length;++i){const r=e.geometries[i].getMutableAttribute(m.T.AUXPOS1);r&&r.data[3]!==t&&(r.data[3]=t,e.geometryVertexAttrsUpdated(e.geometryRecords[i]))}}function b(e,t){const i=(0,c.d)(c.O);return(0,r.pC)(e)&&(i[0]=e[0],i[1]=e[1],i[2]=e[2]),(0,r.pC)(t)?i[3]=t:(0,r.pC)(e)&&e.length>3&&(i[3]=e[3]),i}function A(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:a.O,t=arguments.length>1?arguments[1]:void 0,i=arguments.length>2?arguments[2]:void 0,s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;const n=new Array(3);if((0,r.Wi)(t)||(0,r.Wi)(i))n[0]=1,n[1]=1,n[2]=1;else{let r,s=0;for(let o=2;o>=0;o--){const a=e[o];let l;const c=null!=a,h=0===o&&!r&&!c,p=i[o];"symbol-value"===a||h?l=0!==p?t[o]/p:1:c&&"proportional"!==a&&isFinite(a)&&(l=0!==p?a/p:1),null!=l&&(n[o]=l,r=l,s=Math.max(s,Math.abs(l)))}for(let e=2;e>=0;e--)null==n[e]?n[e]=r:0===n[e]&&(n[e]=.001*s)}for(let r=2;r>=0;r--)n[r]/=s;return(0,a.d)(n)}function x(e){return function(e){return null!=e.isPrimitive}(e)&&(e=[e.width,e.depth,e.height]),w(e)?null:"Symbol sizes may not be negative values"}function w(e){if(Array.isArray(e)){for(const t of e)if(!w(t))return!1;return!0}return null==e||e>=0}function P(e,t,i){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:(0,o.c)();const s=e||0,a=t||0,l=i||0;return 0!==s&&(0,n.o)(r,r,-s/180*Math.PI),0!==a&&(0,n.r)(r,r,a/180*Math.PI),0!==l&&(0,n.n)(r,r,l/180*Math.PI),r}function R(e,t,i){if(null!=i.minDemResolution)return i.minDemResolution;const r=(0,s.c9)(t),n=(0,p.bf)(e)*r,o=(0,p.Ye)(e)*r,a=(0,p.Cb)(e)*(t.isGeographic?1:r);return 0===n&&0===o&&0===a?i.minDemResolutionForPoints:.01*Math.max(n,o,a)}},77648:(e,t,i)=>{i.d(t,{Fb:()=>o,KO:()=>a,sb:()=>n});var r=i(92026),s=i(81020);class n{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.array=e,this.spatialReference=t,this.offset=i}}function o(e){return"array"in e}function a(e,t){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"ground";if((0,s.f)(t))return e.getElevation(t.x,t.y,t.z||0,t.spatialReference,i);if(o(t)){let s=t.offset;return e.getElevation(t.array[s++],t.array[s++],t.array[s]||0,(0,r.Pt)(t.spatialReference,e.spatialReference),i)}return e.getElevation(t[0],t[1],t[2]||0,e.spatialReference,i)}},2522:(e,t,i)=>{i.d(t,{Ch:()=>n,Hl:()=>l,_Z:()=>a,uM:()=>c,vT:()=>s});var r=i(67794);const s=64,n=s/2,o=n/5,a=s/o,l=.25;function c(e,t){return e.fromData(`${t}-marker`,(()=>(0,r.cU)(t,s,n,o)))}},67794:(e,t,i)=>{i.d(t,{Ns:()=>a,Ph:()=>o,cU:()=>l});i(93169);var r=i(46228),s=i(76873),n=i(8548);const o=128,a=.5;function l(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:o,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t*a,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const l=c(e,t,i,r);return new s.x(l,{mipmap:!1,wrap:{s:n.e8.CLAMP_TO_EDGE,t:n.e8.CLAMP_TO_EDGE},width:t,height:t,components:4,noUnpackFlip:!0})}function c(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:o,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t*a,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;switch(e){case"circle":default:return h(t,i);case"square":return p(t,i);case"cross":return u(t,i,r);case"x":return f(t,i,r);case"kite":return d(t,i);case"triangle":return g(t,i);case"arrow":return v(t,i)}}function h(e,t){const i=e/2-.5;return S(e,T(i,i,t/2))}function p(e,t){return m(e,t,!1)}function d(e,t){return m(e,t,!0)}function u(e,t){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return _(e,t,!1,i)}function f(e,t){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return _(e,t,!0,i)}function g(e,t){return S(e,y(e/2,t,t/2))}function v(e,t){const i=t,r=t/2,s=e/2,n=.8*i,o=T(s,(e-t)/2-n,Math.sqrt(n*n+r*r)),a=y(s,i,r);return S(e,((e,t)=>Math.max(a(e,t),-o(e,t))))}function m(e,t,i){return i&&(t/=Math.SQRT2),S(e,((r,s)=>{let n=r-.5*e+.25,o=.5*e-s-.75;if(i){const e=(n+o)/Math.SQRT2;o=(o-n)/Math.SQRT2,n=e}return Math.max(Math.abs(n),Math.abs(o))-.5*t}))}function _(e,t,i){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;t-=r,i&&(t*=Math.SQRT2);const s=.5*t;return S(e,((t,n)=>{let o,a=t-.5*e,l=.5*e-n-1;if(i){const e=(a+l)/Math.SQRT2;l=(l-a)/Math.SQRT2,a=e}return a=Math.abs(a),l=Math.abs(l),o=a>l?a>s?Math.sqrt((a-s)*(a-s)+l*l):l:l>s?Math.sqrt(a*a+(l-s)*(l-s)):a,o-=r/2,o}))}function T(e,t,i){return(r,s)=>{const n=r-e,o=s-t;return Math.sqrt(n*n+o*o)-i}}function y(e,t,i){const r=Math.sqrt(t*t+i*i);return(s,n)=>{const o=Math.abs(s-e)-i,a=n-e+t/2+.75,l=(t*o+i*a)/r,c=-a;return Math.max(l,c)}}function S(e,t){const i=new Uint8Array(4*e*e);for(let s=0;s<e;s++)for(let n=0;n<e;n++){const o=n+e*s;let a=t(n,s);a=a/e+.5,(0,r.I)(a,i,4*o)}return i}},48353:(e,t,i)=>{i.d(t,{U:()=>h});var r=i(49450),s=i(59150),n=i(58406),o=i(699),a=i(98634),l=i(4760),c=i(65964);function h(e,t){const i=e.vertex;i.uniforms.add(new n.p("intrinsicWidth",(e=>e.width))),t.vvSize?(e.attributes.add(l.T.SIZEFEATUREATTRIBUTE,"float"),i.uniforms.add(new r.J("vvSizeMinSize",(e=>e.vvSizeMinSize))),i.uniforms.add(new r.J("vvSizeMaxSize",(e=>e.vvSizeMaxSize))),i.uniforms.add(new r.J("vvSizeOffset",(e=>e.vvSizeOffset))),i.uniforms.add(new r.J("vvSizeFactor",(e=>e.vvSizeFactor))),i.code.add(a.H`float getSize() {
return intrinsicWidth * clamp(vvSizeOffset + sizeFeatureAttribute * vvSizeFactor, vvSizeMinSize, vvSizeMaxSize).x;
}`)):(e.attributes.add(l.T.SIZE,"float"),i.code.add(a.H`float getSize(){
return intrinsicWidth * size;
}`)),t.vvOpacity?(e.attributes.add(l.T.OPACITYFEATUREATTRIBUTE,"float"),i.constants.add("vvOpacityNumber","int",8),i.uniforms.add([new o.O("vvOpacityValues",(e=>e.vvOpacityValues),8),new o.O("vvOpacityOpacities",(e=>e.vvOpacityOpacities),8)]),i.code.add(a.H`float interpolateOpacity( float value ){
if (value <= vvOpacityValues[0]) {
return vvOpacityOpacities[0];
}
for (int i = 1; i < vvOpacityNumber; ++i) {
if (vvOpacityValues[i] >= value) {
float f = (value - vvOpacityValues[i-1]) / (vvOpacityValues[i] - vvOpacityValues[i-1]);
return mix(vvOpacityOpacities[i-1], vvOpacityOpacities[i], f);
}
}
return vvOpacityOpacities[vvOpacityNumber - 1];
}
vec4 applyOpacity( vec4 color ){
return vec4(color.xyz, interpolateOpacity(opacityFeatureAttribute));
}`)):i.code.add(a.H`vec4 applyOpacity( vec4 color ){
return color;
}`),t.vvColor?(e.attributes.add(l.T.COLORFEATUREATTRIBUTE,"float"),i.constants.add("vvColorNumber","int",c.x),i.uniforms.add(new o.O("vvColorValues",(e=>e.vvColorValues),c.x)),i.uniforms.add(new s.b("vvColorColors",(e=>e.vvColorColors),c.x)),i.code.add(a.H`vec4 interpolateColor( float value ) {
if (value <= vvColorValues[0]) {
return vvColorColors[0];
}
for (int i = 1; i < vvColorNumber; ++i) {
if (vvColorValues[i] >= value) {
float f = (value - vvColorValues[i-1]) / (vvColorValues[i] - vvColorValues[i-1]);
return mix(vvColorColors[i-1], vvColorColors[i], f);
}
}
return vvColorColors[vvColorNumber - 1];
}
vec4 getColor(){
return applyOpacity(interpolateColor(colorFeatureAttribute));
}`)):(e.attributes.add(l.T.COLOR,"vec4"),i.code.add(a.H`vec4 getColor(){
return applyOpacity(color);
}`))}},60300:(e,t,i)=>{i.d(t,{q:()=>m,C:()=>T});var r=i(92026),s=i(78980),n=i(82552),o=i(75993),a=i(95276),l=i(58406),c=i(98634),h=i(19253),p=i(97528),d=i(82031),u=i(90045),f=i(67077);function g(e){return(0,r.Wi)(e)?f.Z:4===e.length?e:(0,u.s)(v,e[0],e[1],e[2],1)}const v=(0,f.c)();function m(e,t){e.constants.add("stippleAlphaColorDiscard","float",.001),e.constants.add("stippleAlphaHighlightDiscard","float",.5),t.stippleEnabled?_(e,t):function(e){e.fragment.code.add(c.H`float getStippleAlpha() { return 1.0; }
#define discardByStippleAlpha(_stippleAlpha_, _threshold_) {}
#define blendStipple(color, _stippleAlpha_) color`)}(e)}function _(e,t){const i=!(t.draped&&t.stipplePreferContinuous),{vertex:u,fragment:f}=e;f.include(s.n),t.draped||((0,n.hY)(u,t),u.uniforms.add(new l.p("worldToScreenPerDistanceRatio",((e,t)=>1/t.camera.perScreenPixelRatio))),u.code.add(c.H`float computeWorldToScreenRatio(vec3 segmentCenter) {
float segmentDistanceToCamera = length(segmentCenter - cameraPosition);
return worldToScreenPerDistanceRatio / segmentDistanceToCamera;
}`)),e.varyings.add("vStippleDistance","float"),t.stippleRequiresClamp&&e.varyings.add("vStippleDistanceLimits","vec2"),t.stippleRequiresStretchMeasure&&e.varyings.add("vStipplePatternStretch","float"),u.code.add(c.H`
    float discretizeWorldToScreenRatio(float worldToScreenRatio) {
      float step = ${y};

      float discreteWorldToScreenRatio = log(worldToScreenRatio);
      discreteWorldToScreenRatio = ceil(discreteWorldToScreenRatio / step) * step;
      discreteWorldToScreenRatio = exp(discreteWorldToScreenRatio);
      return discreteWorldToScreenRatio;
    }
  `),u.code.add(c.H`vec2 computeStippleDistanceLimits(float startPseudoScreen, float segmentLengthPseudoScreen, float segmentLengthScreen, float patternLength) {`),u.code.add(c.H`
    if (segmentLengthPseudoScreen >= ${i?"patternLength":"1e4"}) {
  `),u.uniforms.add(new l.p("pixelRatio",((e,t)=>t.camera.pixelRatio))),u.code.add(c.H`
        // Round the screen length to get an integer number of pattern repetitions (minimum 1).
        float repetitions = segmentLengthScreen / (patternLength * pixelRatio);
        float flooredRepetitions = max(1.0, floor(repetitions + 0.5));
        float segmentLengthScreenRounded = flooredRepetitions * patternLength;

        ${t.stippleRequiresStretchMeasure?c.H`
              float stretch = repetitions / flooredRepetitions;

              // We need to impose a lower bound on the stretch factor to prevent the dots from merging together when there is only 1 repetition.
              // 0.75 is the lowest possible stretch value for flooredRepetitions > 1, so it makes sense as lower bound.
              vStipplePatternStretch = max(0.75, stretch);`:""}

        return vec2(0.0, segmentLengthScreenRounded);
      }
      return vec2(startPseudoScreen, startPseudoScreen + segmentLengthPseudoScreen);
    }
  `),f.constants.add("stippleTexturePadding","float",d.it);const v=t.hasWebGL2Context?p.D.None:p.D.Size;f.uniforms.add((0,h.J)("stipplePatternTexture",(e=>e.stippleTexture),v)),f.uniforms.add([new l.p("stipplePatternSDFNormalizer",(e=>function(e){return(0,r.pC)(e)?(Math.floor(.5*((0,d.kj)(e)-1))+.5)/e.pixelRatio:1}(e.stipplePattern))),new l.p("stipplePatternPixelSizeInv",(e=>1/T(e)))]),f.code.add(c.H`
    float padStippleTexture(float u) {
      float paddedTextureSize = ${(0,o.w_)(t,"stipplePatternTexture")}.x;
      float unpaddedTextureSize = paddedTextureSize - stippleTexturePadding;

      return (u * unpaddedTextureSize + stippleTexturePadding * 0.5) / paddedTextureSize;
    }
  `),f.code.add(c.H`
    float getStippleSDF(out bool isClamped) {
      ${t.stippleRequiresClamp?c.H`
          float stippleDistanceClamped = clamp(vStippleDistance, vStippleDistanceLimits.x, vStippleDistanceLimits.y);
          vec2 aaCorrectedLimits = vStippleDistanceLimits + vec2(1.0, -1.0) / gl_FragCoord.w;
          isClamped = vStippleDistance < aaCorrectedLimits.x || vStippleDistance > aaCorrectedLimits.y;`:c.H`
          float stippleDistanceClamped = vStippleDistance;
          isClamped = false;`}

      float u = stippleDistanceClamped * gl_FragCoord.w * stipplePatternPixelSizeInv;
      ${t.stippleScaleWithLineWidth?c.H`u *= vLineSizeInv;`:""}
      u = padStippleTexture(fract(u));

      float encodedSDF = rgba2float(texture2D(stipplePatternTexture, vec2(u, 0.5)));
      float sdf = (encodedSDF * 2.0 - 1.0) * stipplePatternSDFNormalizer;

      ${t.stippleRequiresStretchMeasure?c.H`return (sdf - 0.5) * vStipplePatternStretch + 0.5;`:c.H`return sdf;`}
    }

    float getStippleSDF() {
      bool ignored;
      return getStippleSDF(ignored);
    }

    float getStippleAlpha() {
      bool isClamped;
      float stippleSDF = getStippleSDF(isClamped);

      float antiAliasedResult = ${t.stippleScaleWithLineWidth?c.H`clamp(stippleSDF * vLineWidth + 0.5, 0.0, 1.0);`:c.H`clamp(stippleSDF + 0.5, 0.0, 1.0);`}

      return isClamped ? floor(antiAliasedResult + 0.5) : antiAliasedResult;
    }
  `),t.stippleOffColorEnabled?(f.uniforms.add(new a.N("stippleOffColor",(e=>g(e.stippleOffColor)))),f.code.add(c.H`#define discardByStippleAlpha(stippleAlpha, threshold) {}
#define blendStipple(color, stippleAlpha) mix(color, stippleOffColor, stippleAlpha)`)):f.code.add(c.H`#define discardByStippleAlpha(stippleAlpha, threshold) if (stippleAlpha < threshold) { discard; }
#define blendStipple(color, stippleAlpha) vec4(color.rgb, color.a * stippleAlpha)`)}function T(e){const t=e.stipplePattern;return(0,r.pC)(t)?(0,d.$A)(e.stipplePattern)/t.pixelRatio:1}const y=c.H.float(.4)},40526:(e,t,i)=>{i.d(t,{Q:()=>l});var r=i(92026),s=i(2522),n=i(58406),o=i(98634),a=i(33720);function l(e,t){const i=e.vertex;e.constants.add("markerSizePerLineWidth","float",s._Z),i.uniforms.add(new n.p("pixelRatio",((e,t)=>t.camera.pixelRatio))),(0,r.Wi)(i.uniforms.get("markerScale"))&&i.constants.add("markerScale","float",1),i.code.add(o.H`float getLineWidth() {
return max(getSize(), 1.0) * pixelRatio;
}
float getScreenMarkerSize() {
return markerSizePerLineWidth * markerScale * getLineWidth();
}`),t.space===a.I9.World&&(i.constants.add("maxSegmentLengthFraction","float",.45),i.uniforms.add(new n.p("perRenderPixelRatio",((e,t)=>t.camera.perRenderPixelRatio))),i.code.add(o.H`float getWorldMarkerSize(vec4 pos) {
float distanceToCamera = length(pos.xyz);
float screenToWorldRatio = perRenderPixelRatio * distanceToCamera * 0.5;
return getScreenMarkerSize() * screenToWorldRatio;
}
bool areWorldMarkersHidden(vec4 pos, vec4 other) {
vec3 midPoint = mix(pos.xyz, other.xyz, 0.5);
float distanceToCamera = length(midPoint);
float screenToWorldRatio = perRenderPixelRatio * distanceToCamera * 0.5;
float worldMarkerSize = getScreenMarkerSize() * screenToWorldRatio;
float segmentLen = length(pos.xyz - other.xyz);
return worldMarkerSize > maxSegmentLengthFraction * segmentLen;
}`))}},30425:(e,t,i)=>{i.d(t,{V:()=>y});var r=i(32718),s=i(16889),n=i(92026),o=i(17842),a=i(14226),l=i(81949),c=i(88396),h=i(6394),p=i(11186),d=i(71353),u=i(90045),f=i(67077),g=i(95773),v=i(40885),m=i(40927),_=i(50951),T=i(97731);class y{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;this._viewUp=(0,d.c)(),this._viewForward=(0,d.c)(),this._viewRight=(0,d.c)(),this._ray=(0,v.Ue)(),this._viewport=(0,f.f)(0,0,1,1),this._padding=(0,f.f)(0,0,0,0),this._fov=55/180*Math.PI,this._nearFar=(0,h.f)(1,1e3),this._viewDirty=!0,this._viewMatrix=(0,l.c)(),this._projectionDirty=!0,this._projectionMatrix=(0,l.c)(),this._viewProjectionDirty=!0,this._viewProjectionMatrix=(0,l.c)(),this._viewInverseTransposeMatrixDirty=!0,this._viewInverseTransposeMatrix=(0,l.c)(),this._inverseProjectionDirty=!0,this._inverseProjectionMatrix=null,this._frustumDirty=!0,this._frustum=(0,g.Ue)(),this._fullViewport=(0,f.c)(),this._pixelRatio=1,this.relativeElevation=0,(0,n.pC)(e)&&(0,p.c)(this._ray.origin,e),this._center=(0,n.pC)(t)?(0,d.a)(t):(0,d.c)(),this._up=(0,n.pC)(i)?(0,d.a)(i):(0,d.f)(0,0,1)}get pixelRatio(){return this._pixelRatio}set pixelRatio(e){this._pixelRatio=e>0?e:1}get eye(){return this._ray.origin}set eye(e){this._compareAndSetView(e,this._ray.origin)}get center(){return this._center}set center(e){this._compareAndSetView(e,this._center)}get ray(){return(0,p.b)(this._ray.direction,this.center,this.eye),this._ray}get up(){return this._up}set up(e){this._compareAndSetView(e,this._up)}get viewMatrix(){return this._ensureViewClean(),this._viewMatrix}set viewMatrix(e){(0,a.c)(this._viewMatrix,e),this._viewDirty=!1,this._viewInverseTransposeMatrixDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0}get viewForward(){return this._ensureViewClean(),this._viewForward}get viewUp(){return this._ensureViewClean(),this._viewUp}get viewRight(){return this._ensureViewClean(),this._viewRight}get nearFar(){return this._nearFar}get near(){return this._nearFar[0]}set near(e){this._nearFar[0]!==e&&(this._nearFar[0]=e,this._projectionDirty=!0,this._inverseProjectionDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0)}get far(){return this._nearFar[1]}set far(e){this._nearFar[1]!==e&&(this._nearFar[1]=e,this._projectionDirty=!0,this._inverseProjectionDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0)}get viewport(){return this._viewport}set viewport(e){this.x=e[0],this.y=e[1],this.width=e[2],this.height=e[3]}get x(){return this._viewport[0]}set x(e){e+=this._padding[w.LEFT],this._viewport[0]!==e&&(this._viewport[0]=e,this._projectionDirty=!0,this._inverseProjectionDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0)}get y(){return this._viewport[1]}set y(e){e+=this._padding[w.BOTTOM],this._viewport[1]!==e&&(this._viewport[1]=e,this._projectionDirty=!0,this._inverseProjectionDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0)}get width(){return this._viewport[2]}set width(e){this._viewport[2]!==e&&(this._viewport[2]=e,this._projectionDirty=!0,this._inverseProjectionDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0)}get height(){return this._viewport[3]}set height(e){this._viewport[3]!==e&&(this._viewport[3]=e,this._projectionDirty=!0,this._inverseProjectionDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0)}get fullWidth(){return this._viewport[2]+this._padding[w.RIGHT]+this._padding[w.LEFT]}set fullWidth(e){this.width=e-(this._padding[w.RIGHT]+this._padding[w.LEFT])}get fullHeight(){return this._viewport[3]+this._padding[w.TOP]+this._padding[w.BOTTOM]}set fullHeight(e){this.height=e-(this._padding[w.TOP]+this._padding[w.BOTTOM])}get fullViewport(){return this._fullViewport[0]=this._viewport[0]-this._padding[w.LEFT],this._fullViewport[1]=this._viewport[1]-this._padding[w.BOTTOM],this._fullViewport[2]=this.fullWidth,this._fullViewport[3]=this.fullHeight,this._fullViewport}get aspect(){return this.width/this.height}get padding(){return this._padding}set padding(e){this._padding[w.TOP]===e[w.TOP]&&this._padding[w.RIGHT]===e[w.RIGHT]&&this._padding[w.BOTTOM]===e[w.BOTTOM]&&this._padding[w.LEFT]===e[w.LEFT]||(this._viewport[0]+=e[w.LEFT]-this._padding[w.LEFT],this._viewport[1]+=e[w.BOTTOM]-this._padding[w.BOTTOM],this._viewport[2]-=e[w.RIGHT]+e[w.LEFT]-(this._padding[w.RIGHT]+this._padding[w.LEFT]),this._viewport[3]-=e[w.TOP]+e[w.BOTTOM]-(this._padding[w.TOP]+this._padding[w.BOTTOM]),(0,u.c)(this._padding,e),this._projectionDirty=!0,this._inverseProjectionDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0)}get viewProjectionMatrix(){return this._viewProjectionDirty&&((0,a.m)(this._viewProjectionMatrix,this.projectionMatrix,this.viewMatrix),this._viewProjectionDirty=!1),this._viewProjectionMatrix}get projectionMatrix(){if(this._projectionDirty){const e=this.width,t=this.height,i=this.near*Math.tan(this.fovY/2),r=i*this.aspect;(0,a.p)(this._projectionMatrix,-r*(1+2*this._padding[w.LEFT]/e),r*(1+2*this._padding[w.RIGHT]/e),-i*(1+2*this._padding[w.BOTTOM]/t),i*(1+2*this._padding[w.TOP]/t),this.near,this.far),this._projectionDirty=!1}return this._projectionMatrix}get inverseProjectionMatrix(){return(0,n.Wi)(this._inverseProjectionMatrix)&&(this._inverseProjectionMatrix=(0,l.c)()),this._inverseProjectionDirty&&(0,a.a)(this._inverseProjectionMatrix,this.projectionMatrix),this._inverseProjectionMatrix}set projectionMatrix(e){(0,a.c)(this._projectionMatrix,e),this._projectionDirty=!1,this._inverseProjectionDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0}get fov(){return this._fov}set fov(e){this._fov=e,this._projectionDirty=!0,this._inverseProjectionDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0}get fovX(){return(0,T.tM)(this._fov,this.width,this.height)}set fovX(e){this._fov=(0,T.Kj)(e,this.width,this.height),this._projectionDirty=!0,this._inverseProjectionDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0}get fovY(){return(0,T.RQ)(this._fov,this.width,this.height)}set fovY(e){this._fov=(0,T.zF)(e,this.width,this.height),this._projectionDirty=!0,this._inverseProjectionDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0}get distance(){return(0,p.i)(this._center,this.eye)}get frustum(){return this._recomputeFrustum(),this._frustum}get viewInverseTransposeMatrix(){return(this._viewInverseTransposeMatrixDirty||this._viewDirty)&&((0,a.a)(this._viewInverseTransposeMatrix,this.viewMatrix),(0,a.t)(this._viewInverseTransposeMatrix,this._viewInverseTransposeMatrix),this._viewInverseTransposeMatrixDirty=!1),this._viewInverseTransposeMatrix}depthNDCToWorld(e){const t=2*e-1;return 2*this.near*this.far/(this.far+this.near-t*(this.far-this.near))}get perRenderPixelRatio(){return Math.tan(this.fovX/2)/(this.width/2)}get perScreenPixelRatio(){return this.perRenderPixelRatio*this._pixelRatio}get aboveGround(){return null!=this.relativeElevation&&this.relativeElevation>=0}copyFrom(e){(0,p.c)(this._ray.origin,e.eye),(0,p.c)(this._center,e.center),(0,p.c)(this._up,e.up),(0,u.c)(this._viewport,e.viewport),(0,u.c)(this._padding,e.padding),(0,c.c)(this._nearFar,e.nearFar),this._fov=e.fov,this.relativeElevation=e.relativeElevation;const t=e;return this._viewDirty=t._viewDirty,this._viewDirty||((0,a.c)(this._viewMatrix,e.viewMatrix),(0,p.c)(this._viewRight,e.viewRight),(0,p.c)(this._viewUp,e.viewUp),(0,p.c)(this._viewForward,e.viewForward)),t._projectionDirty?this._projectionDirty=!0:((0,a.c)(this._projectionMatrix,e.projectionMatrix),this._projectionDirty=!1),this._viewProjectionDirty=!0,this._inverseProjectionDirty=!0,this._frustumDirty=t._frustumDirty,this._frustumDirty||((0,g.JG)(this._frustum,e.frustum),this._frustumDirty=!1),t._viewInverseTransposeMatrixDirty?this._viewInverseTransposeMatrixDirty=!0:((0,a.c)(this._viewInverseTransposeMatrix,e.viewInverseTransposeMatrix),this._viewInverseTransposeMatrixDirty=!1),(0,u.c)(this._fullViewport,e.fullViewport),this._pixelRatio=e.pixelRatio,this}copyViewFrom(e){this.eye=e.eye,this.center=e.center,this.up=e.up}clone(){return(new y).copyFrom(this)}equals(e){return(0,p.k)(this.eye,e.eye)&&(0,p.k)(this._center,e.center)&&(0,p.k)(this._up,e.up)&&(0,u.g)(this._viewport,e.viewport)&&(0,u.g)(this._padding,e.padding)&&(0,c.m)(this._nearFar,e.nearFar)&&this._fov===e.fov&&this._pixelRatio===e.pixelRatio&&this.relativeElevation===e.relativeElevation}almostEquals(e){if(this._pixelRatio!==e.pixelRatio||Math.abs(e.fov-this._fov)>=.001)return!1;const t=5e-4;(0,p.y)(b,e.eye,e.center),(0,p.y)(A,this.eye,this._center);const i=(0,p.e)(b,A),r=(0,p.D)(b),s=(0,p.D)(A);return i*i>=(1-1e-10)*r*s&&(0,p.E)(e.eye,this.eye)<Math.max(r,s)*t*t&&(0,u.i)(e.padding,this._padding)<.5&&(0,u.i)(e.viewport,this._viewport)<.5}computeRenderPixelSizeAt(e){return this.computeRenderPixelSizeAtDist(this._viewDirectionDistance(e))}computeRenderPixelSizeAtDist(e){return e*this.perRenderPixelRatio}computeScreenPixelSizeAt(e){return this.computeScreenPixelSizeAtDist(this._viewDirectionDistance(e))}_viewDirectionDistance(e){return Math.abs((0,m.SR)(this.viewForward,(0,p.b)(b,e,this.eye)))}computeScreenPixelSizeAtDist(e){return e*this.perScreenPixelRatio}computeDistanceFromRadius(e,t){return e/Math.tan(Math.min(this.fovX,this.fovY)/(2*(t||1)))}getScreenCenter(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:(0,o.s1)();return e[0]=(this.padding[w.LEFT]+this.width/2)/this._pixelRatio,e[1]=(this.padding[w.TOP]+this.height/2)/this._pixelRatio,e}getRenderCenter(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.5,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.5;return e[0]=this.padding[w.LEFT]+this.width*t,e[1]=this.padding[w.BOTTOM]+this.height*i,e[2]=.5,e}setGLViewport(e){const t=this.viewport,i=this.padding;e.setViewport(t[0]-i[3],t[1]-i[2],t[2]+i[1]+i[3],t[3]+i[0]+i[2])}applyProjection(e,t){e!==S&&(0,p.c)(S,e),S[3]=1,(0,u.t)(S,S,this.projectionMatrix);const i=Math.abs(S[3]);(0,p.g)(S,S,1/i);const r=this.fullViewport;t[0]=(0,s.t7)(0,r[0]+r[2],.5+.5*S[0]),t[1]=(0,s.t7)(0,r[1]+r[3],.5+.5*S[1]),t[2]=.5*(S[2]+1),t[3]=i}unapplyProjection(e,t){const i=this.fullViewport;S[0]=(e[0]/(i[0]+i[2])*2-1)*e[3],S[1]=(e[1]/(i[1]+i[3])*2-1)*e[3],S[2]=(2*e[2]-1)*e[3],S[3]=e[3],(0,u.t)(S,S,this.inverseProjectionMatrix),t[0]=S[0],t[1]=S[1],t[2]=S[2]}projectToScreen(e,t){return this.projectToRenderScreen(e,x),this.renderToScreen(x,t),t}projectToRenderScreen(e,t){if(S[0]=e[0],S[1]=e[1],S[2]=e[2],S[3]=1,(0,u.t)(S,S,this.viewProjectionMatrix),0===S[3])return null;(0,p.g)(S,S,1/Math.abs(S[3]));const i=this.fullViewport;return"x"in t?(t.x=(0,s.t7)(0,i[0]+i[2],.5+.5*S[0]),t.y=(0,s.t7)(0,i[1]+i[3],.5+.5*S[1])):(t[0]=(0,s.t7)(0,i[0]+i[2],.5+.5*S[0]),t[1]=(0,s.t7)(0,i[1]+i[3],.5+.5*S[1]),t.length>2&&(t[2]=.5*(S[2]+1))),t}unprojectFromScreen(e,t){return this.unprojectFromRenderScreen(this.screenToRender(e,x),t)}unprojectFromRenderScreen(e,t){if((0,a.m)(O,this.projectionMatrix,this.viewMatrix),!(0,a.a)(O,O))return null;const i=this.fullViewport;return S[0]=2*(e[0]-i[0])/i[2]-1,S[1]=2*(e[1]-i[1])/i[3]-1,S[2]=2*e[2]-1,S[3]=1,(0,u.t)(S,S,O),0===S[3]?null:(t[0]=S[0]/S[3],t[1]=S[1]/S[3],t[2]=S[2]/S[3],t)}constrainWindowSize(e,t,i){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:i;const s=e*this._pixelRatio,n=t*this._pixelRatio,o=Math.max(s-i/2,0),a=Math.max(this.fullHeight-n-r/2,0),l=-Math.min(s-i/2,0),c=-Math.min(this.fullHeight-n-r/2,0);return[o,a,i-l- -Math.min(this.fullWidth-s-i/2,0),r-c- -Math.min(n-r/2,0)]}computeUp(e){e===_.JY.Global?this._computeUpGlobal():this._computeUpLocal()}screenToRender(e,t){const i=e[0]*this._pixelRatio,r=this.fullHeight-e[1]*this._pixelRatio;return t[0]=i,t[1]=r,t}renderToScreen(e,t){const i=e[0]/this._pixelRatio,r=(this.fullHeight-e[1])/this._pixelRatio;t[0]=i,t[1]=r}_computeUpGlobal(){(0,p.b)(b,this.center,this.eye);const e=(0,p.l)(this.center);e<1?((0,p.s)(this._up,0,0,1),this._markViewDirty()):Math.abs((0,p.e)(b,this.center))>.9999*(0,p.l)(b)*e||((0,p.f)(this._up,b,this.center),(0,p.f)(this._up,this._up,b),(0,p.n)(this._up,this._up),this._markViewDirty())}_computeUpLocal(){(0,p.r)(b,this.eye,this.center),Math.abs(b[2])<=.9999&&((0,p.g)(b,b,b[2]),(0,p.s)(this._up,-b[0],-b[1],1-b[2]),(0,p.n)(this._up,this._up),this._markViewDirty())}_compareAndSetView(e,t){"number"==typeof e[0]&&isFinite(e[0])&&"number"==typeof e[1]&&isFinite(e[1])&&"number"==typeof e[2]&&isFinite(e[2])?(0,p.k)(e,t)||((0,p.c)(t,e),this._markViewDirty()):r.Z.getLogger("esri.views.3d.webgl-engine.lib.Camera").warn("Camera vector contains invalid number, ignoring value")}_markViewDirty(){this._viewDirty=!0,this._frustumDirty=!0,this._viewProjectionDirty=!0}_recomputeFrustum(){this._frustumDirty&&((0,g.q_)(this.viewMatrix,this.projectionMatrix,this._frustum),this._frustumDirty=!1)}_ensureViewClean(){this._viewDirty&&((0,a.q)(this._viewMatrix,this.eye,this._center,this._up),(0,p.s)(this._viewForward,-this._viewMatrix[2],-this._viewMatrix[6],-this._viewMatrix[10]),(0,p.s)(this._viewUp,this._viewMatrix[1],this._viewMatrix[5],this._viewMatrix[9]),(0,p.s)(this._viewRight,this._viewMatrix[0],this._viewMatrix[4],this._viewMatrix[8]),this._viewDirty=!1,this._viewInverseTransposeMatrixDirty=!0)}}const S=(0,f.c)(),O=(0,l.c)(),b=(0,d.c)(),A=(0,d.c)(),x=(0,o.J$)();var w;!function(e){e[e.TOP=0]="TOP",e[e.RIGHT=1]="RIGHT",e[e.BOTTOM=2]="BOTTOM",e[e.LEFT=3]="LEFT"}(w||(w={}))},70619:(e,t,i)=>{i.d(t,{Cr:()=>L,IG:()=>_,QL:()=>A,nb:()=>x,B2:()=>T,DA:()=>C,x2:()=>P,dV:()=>b,mj:()=>O,rh:()=>R,PI:()=>S,AW:()=>y,PD:()=>w,Ay:()=>E,mx:()=>D});var r,s=i(11186),n=i(8229),o=i(71353),a=i(55652),l=i(40885),c=i(68401);!function(e){e.length=function(e,t){const i=e[t],r=e[t+1],s=e[t+2];return Math.sqrt(i*i+r*r+s*s)},e.normalize=function(e,t){const i=e[t],r=e[t+1],s=e[t+2],n=1/Math.sqrt(i*i+r*r+s*s);e[t]*=n,e[t+1]*=n,e[t+2]*=n},e.scale=function(e,t,i){e[t]*=i,e[t+1]*=i,e[t+2]*=i},e.add=function(e,t,i,r,s){let n=arguments.length>5&&void 0!==arguments[5]?arguments[5]:t;(s=s||e)[n]=e[t]+i[r],s[n+1]=e[t+1]+i[r+1],s[n+2]=e[t+2]+i[r+2]},e.subtract=function(e,t,i,r,s){let n=arguments.length>5&&void 0!==arguments[5]?arguments[5]:t;(s=s||e)[n]=e[t]-i[r],s[n+1]=e[t+1]-i[r+1],s[n+2]=e[t+2]-i[r+2]}}(r||(r={}));var h=i(74894),p=i(72838),d=i(97731),u=i(4760);const f=r;var g,v,m;!function(e){const t=.5,i=[[-t,-t,t],[t,-t,t],[t,t,t],[-t,t,t],[-t,-t,-t],[t,-t,-t],[t,t,-t],[-t,t,-t]],r=[0,0,1,-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,-1],s=[0,0,1,0,1,1,0,1],n=[0,1,2,2,3,0,4,0,3,3,7,4,1,5,6,6,2,1,1,0,4,4,5,1,3,2,6,6,7,3,5,4,7,7,6,5],o=new Array(36);for(let l=0;l<6;l++)for(let e=0;e<6;e++)o[6*l+e]=l;const a=new Array(36);for(let l=0;l<6;l++)a[6*l+0]=0,a[6*l+1]=1,a[6*l+2]=2,a[6*l+3]=2,a[6*l+4]=3,a[6*l+5]=0;e.createGeometry=function(e){Array.isArray(e)||(e=[e,e,e]);const t=new Array(24);for(let r=0;r<8;r++)t[3*r]=i[r][0]*e[0],t[3*r+1]=i[r][1]*e[1],t[3*r+2]=i[r][2]*e[2];return new h.Z([[u.T.POSITION,{size:3,data:t,exclusive:!0}],[u.T.NORMAL,{size:3,data:r}],[u.T.UV0,{size:2,data:s}]],[[u.T.POSITION,n],[u.T.NORMAL,o],[u.T.UV0,a]])}}(g||(g={})),function(e){const t=.5,i=[[-t,0,-t],[t,0,-t],[t,0,t],[-t,0,t],[0,-t,0],[0,t,0]],r=[0,1,-1,1,1,0,0,1,1,-1,1,0,0,-1,-1,1,-1,0,0,-1,1,-1,-1,0],s=[5,1,0,5,2,1,5,3,2,5,0,3,4,0,1,4,1,2,4,2,3,4,3,0],n=[0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7];e.createGeometry=function(e){Array.isArray(e)||(e=[e,e,e]);const t=new Array(18);for(let r=0;r<6;r++)t[3*r]=i[r][0]*e[0],t[3*r+1]=i[r][1]*e[1],t[3*r+2]=i[r][2]*e[2];return new h.Z([[u.T.POSITION,{size:3,data:t,exclusive:!0}],[u.T.NORMAL,{size:3,data:r}]],[[u.T.POSITION,s],[u.T.NORMAL,n]])}}(v||(v={})),function(e){const t=.5,i=(0,n.f)(-t,0,-t),r=(0,n.f)(t,0,-t),o=(0,n.f)(0,0,t),a=(0,n.f)(0,.5,0),l=(0,n.c)(),c=(0,n.c)(),p=(0,n.c)(),d=(0,n.c)(),f=(0,n.c)();(0,s.b)(l,i,a),(0,s.b)(c,i,r),(0,s.f)(p,l,c),(0,s.n)(p,p),(0,s.b)(l,r,a),(0,s.b)(c,r,o),(0,s.f)(d,l,c),(0,s.n)(d,d),(0,s.b)(l,o,a),(0,s.b)(c,o,i),(0,s.f)(f,l,c),(0,s.n)(f,f);const g=[i,r,o,a],v=[0,-1,0,p[0],p[1],p[2],d[0],d[1],d[2],f[0],f[1],f[2]],m=[0,1,2,3,1,0,3,2,1,3,0,2],_=[0,0,0,1,1,1,2,2,2,3,3,3];e.createGeometry=function(e){Array.isArray(e)||(e=[e,e,e]);const t=new Array(12);for(let i=0;i<4;i++)t[3*i]=g[i][0]*e[0],t[3*i+1]=g[i][1]*e[1],t[3*i+2]=g[i][2]*e[2];return new h.Z([[u.T.POSITION,{size:3,data:t,exclusive:!0}],[u.T.NORMAL,{size:3,data:v}]],[[u.T.POSITION,m],[u.T.NORMAL,_]])}}(m||(m={}));const _=g.createGeometry,T=v.createGeometry,y=m.createGeometry;function S(e,t,i){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{uv:!0};const s=-Math.PI,n=2*Math.PI,o=-Math.PI/2,a=Math.PI,l=Math.max(3,Math.floor(t)),c=Math.max(2,Math.floor(i)),p=(l+1)*(c+1),d=new Float32Array(3*p),f=new Float32Array(3*p),g=new Float32Array(2*p),v=[];let m=0;for(let h=0;h<=c;h++){const t=[],i=h/c,r=o+i*a,p=Math.cos(r);for(let o=0;o<=l;o++){const a=o/l,c=s+a*n,h=Math.cos(c)*p,u=Math.sin(r),v=-Math.sin(c)*p;d[3*m]=h*e,d[3*m+1]=u*e,d[3*m+2]=v*e,f[3*m]=h,f[3*m+1]=u,f[3*m+2]=v,g[2*m]=a,g[2*m+1]=i,t.push(m),++m}v.push(t)}const _=new Array;for(let h=0;h<c;h++)for(let e=0;e<l;e++){const t=v[h][e],i=v[h][e+1],r=v[h+1][e+1],s=v[h+1][e];0===h?(_.push(t),_.push(r),_.push(s)):h===c-1?(_.push(t),_.push(i),_.push(r)):(_.push(t),_.push(i),_.push(r),_.push(r),_.push(s),_.push(t))}const T=[[u.T.POSITION,_],[u.T.NORMAL,_]],y=[[u.T.POSITION,{size:3,data:d,exclusive:!0}],[u.T.NORMAL,{size:3,data:f,exclusive:!0}]];return r.uv&&(y.push([u.T.UV0,{size:2,data:g,exclusive:!0}]),T.push([u.T.UV0,_])),r.offset&&(T[0][0]=u.T.OFFSET,y[0][0]=u.T.OFFSET,T.push([u.T.POSITION,new Array(_.length).fill(0)]),y.push([u.T.POSITION,{size:3,data:Float64Array.from(r.offset),exclusive:!0}])),new h.Z(y,T)}function O(e,t,i){const r=e;let s,n;if(i)s=[0,-1,0,1,0,0,0,0,1,-1,0,0,0,0,-1,0,1,0],n=[0,1,2,0,2,3,0,3,4,0,4,1,1,5,2,2,5,3,3,5,4,4,5,1];else{const e=r*(1+Math.sqrt(5))/2;s=[-r,e,0,r,e,0,-r,-e,0,r,-e,0,0,-r,e,0,r,e,0,-r,-e,0,r,-e,e,0,-r,e,0,r,-e,0,-r,-e,0,r],n=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1]}for(let h=0;h<s.length;h+=3)f.scale(s,h,e/f.length(s,h));let o={};function a(t,i){t>i&&([t,i]=[i,t]);const r=t.toString()+"."+i.toString();if(o[r])return o[r];let n=s.length;return s.length+=3,f.add(s,3*t,s,3*i,s,n),f.scale(s,n,e/f.length(s,n)),n/=3,o[r]=n,n}for(let h=0;h<t;h++){const e=n.length,t=new Array(4*e);for(let i=0;i<e;i+=3){const e=n[i],r=n[i+1],s=n[i+2],o=a(e,r),l=a(r,s),c=a(s,e),h=4*i;t[h]=e,t[h+1]=o,t[h+2]=c,t[h+3]=r,t[h+4]=l,t[h+5]=o,t[h+6]=s,t[h+7]=c,t[h+8]=l,t[h+9]=o,t[h+10]=l,t[h+11]=c}n=t,o={}}const l=new Float32Array(s);for(let h=0;h<l.length;h+=3)f.normalize(l,h);const c=[[u.T.POSITION,n],[u.T.NORMAL,n]],p=[[u.T.POSITION,{size:3,data:new Float32Array(s),exclusive:!0}],[u.T.NORMAL,{size:3,data:l,exclusive:!0}]];return new h.Z(p,c)}function b(e,t,i,r,s,n,o,a){const l=t?[t[0],t[1],t[2]]:[0,0,0],p=e?[e[0],e[1],e[2]]:[0,0,1];n=n||[0,0];const d=i?[255*i[0],255*i[1],255*i[2],i.length>3?255*i[3]:255]:[255,255,255,255],f=null!=r&&2===r.length?r:[1,1],g=[[u.T.POSITION,{size:3,data:l,exclusive:!0}],[u.T.NORMAL,{size:3,data:p,exclusive:!0}],[u.T.UV0,{size:n.length,data:n}],[u.T.COLOR,{size:4,data:d,exclusive:!0}],[u.T.SIZE,{size:2,data:f}]];if(null!=s){const e=new Float32Array([s[0],s[1],s[2],s[3]]);g.push([u.T.AUXPOS1,{size:4,data:e}])}if(null!=o){const e=new Float32Array([o[0],o[1],o[2],o[3]]);g.push([u.T.AUXPOS2,{size:4,data:e}])}return new h.Z(g,null,c.MX.Point,a)}function A(e,t,i,r){let s=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],o=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],a=0;const l=t,c=e;let p=(0,n.f)(0,a,0),d=(0,n.f)(0,a+c,0),f=(0,n.f)(0,-1,0),g=(0,n.f)(0,1,0);r&&(a=c,d=(0,n.f)(0,0,0),p=(0,n.f)(0,a,0),f=(0,n.f)(0,1,0),g=(0,n.f)(0,-1,0));const v=[d,p],m=[f,g],_=i+2,T=Math.sqrt(c*c+l*l);if(r)for(let h=i-1;h>=0;h--){const e=h*(2*Math.PI/i),t=(0,n.f)(Math.cos(e)*l,a,Math.sin(e)*l);v.push(t);const r=(0,n.f)(c*Math.cos(e)/T,-l/T,c*Math.sin(e)/T);m.push(r)}else for(let h=0;h<i;h++){const e=h*(2*Math.PI/i),t=(0,n.f)(Math.cos(e)*l,a,Math.sin(e)*l);v.push(t);const r=(0,n.f)(c*Math.cos(e)/T,l/T,c*Math.sin(e)/T);m.push(r)}const y=new Array,S=new Array;if(s){for(let e=3;e<v.length;e++)y.push(1),y.push(e-1),y.push(e),S.push(0),S.push(0),S.push(0);y.push(v.length-1),y.push(2),y.push(1),S.push(0),S.push(0),S.push(0)}if(o){for(let e=3;e<v.length;e++)y.push(e),y.push(e-1),y.push(0),S.push(e),S.push(e-1),S.push(1);y.push(0),y.push(2),y.push(v.length-1),S.push(1),S.push(2),S.push(m.length-1)}const O=new Float32Array(3*_);for(let n=0;n<_;n++)O[3*n]=v[n][0],O[3*n+1]=v[n][1],O[3*n+2]=v[n][2];const b=new Float32Array(3*_);for(let n=0;n<_;n++)b[3*n]=m[n][0],b[3*n+1]=m[n][1],b[3*n+2]=m[n][2];const A=[[u.T.POSITION,y],[u.T.NORMAL,S]],x=[[u.T.POSITION,{size:3,data:O,exclusive:!0}],[u.T.NORMAL,{size:3,data:b,exclusive:!0}]];return new h.Z(x,A)}function x(e,t,i,r,o,a){const l=r?(0,n.b)(r):(0,n.f)(1,0,0),c=o?(0,n.b)(o):(0,n.f)(0,0,0);a=a??!0;const p=(0,n.c)();(0,s.n)(p,l);const d=(0,n.c)();(0,s.g)(d,p,Math.abs(e));const f=(0,n.c)();(0,s.g)(f,d,-.5),(0,s.a)(f,f,c);const g=(0,n.f)(0,1,0);Math.abs(1-(0,s.e)(p,g))<.2&&(0,s.s)(g,0,0,1);const v=(0,n.c)();(0,s.f)(v,p,g),(0,s.n)(v,v),(0,s.f)(g,v,p);const m=2*i+(a?2:0),_=i+(a?2:0),T=new Float32Array(3*m),y=new Float32Array(3*_),S=new Float32Array(2*m),O=new Array(3*i*(a?4:2)),b=new Array(3*i*(a?4:2));a&&(T[3*(m-2)+0]=f[0],T[3*(m-2)+1]=f[1],T[3*(m-2)+2]=f[2],S[2*(m-2)]=0,S[2*(m-2)+1]=0,T[3*(m-1)+0]=T[3*(m-2)+0]+d[0],T[3*(m-1)+1]=T[3*(m-2)+1]+d[1],T[3*(m-1)+2]=T[3*(m-2)+2]+d[2],S[2*(m-1)]=1,S[2*(m-1)+1]=1,y[3*(_-2)+0]=-p[0],y[3*(_-2)+1]=-p[1],y[3*(_-2)+2]=-p[2],y[3*(_-1)+0]=p[0],y[3*(_-1)+1]=p[1],y[3*(_-1)+2]=p[2]);const A=(e,t,i)=>{O[e]=t,b[e]=i};let x=0;const w=(0,n.c)(),P=(0,n.c)();for(let n=0;n<i;n++){const e=n*(2*Math.PI/i);(0,s.g)(w,g,Math.sin(e)),(0,s.g)(P,v,Math.cos(e)),(0,s.a)(w,w,P),y[3*n+0]=w[0],y[3*n+1]=w[1],y[3*n+2]=w[2],(0,s.g)(w,w,t),(0,s.a)(w,w,f),T[3*n+0]=w[0],T[3*n+1]=w[1],T[3*n+2]=w[2],S[2*n+0]=n/i,S[2*n+1]=0,T[3*(n+i)+0]=T[3*n+0]+d[0],T[3*(n+i)+1]=T[3*n+1]+d[1],T[3*(n+i)+2]=T[3*n+2]+d[2],S[2*(n+i)+0]=n/i,S[2*n+1]=1;const r=(n+1)%i;A(x++,n,n),A(x++,n+i,n),A(x++,r,r),A(x++,r,r),A(x++,n+i,n),A(x++,r+i,r)}if(a){for(let e=0;e<i;e++){const t=(e+1)%i;A(x++,m-2,_-2),A(x++,e,_-2),A(x++,t,_-2)}for(let e=0;e<i;e++){const t=(e+1)%i;A(x++,e+i,_-1),A(x++,m-1,_-1),A(x++,t+i,_-1)}}const R=[[u.T.POSITION,O],[u.T.NORMAL,b],[u.T.UV0,O]],C=[[u.T.POSITION,{size:3,data:T,exclusive:!0}],[u.T.NORMAL,{size:3,data:y,exclusive:!0}],[u.T.UV0,{size:2,data:S,exclusive:!0}]];return new h.Z(C,R)}function w(e,t,i,r,s){i=i||10,r=null==r||r,(0,d.hu)(e.length>1);const n=[],o=[];for(let a=0;a<i;a++){n.push([0,-a-1,-(a+1)%i-1]);const e=a/i*2*Math.PI;o.push([Math.cos(e)*t,Math.sin(e)*t])}return P(o,e,[[0,0,0]],n,r,s)}function P(e,t,i,r,c){let p=arguments.length>5&&void 0!==arguments[5]?arguments[5]:(0,n.f)(0,0,0);const d=e.length,f=new Float32Array(t.length*d*3+(6*i.length||0)),g=new Float32Array(t.length*d*3+(i?6:0)),v=new Array,m=new Array;let _=0,T=0;const y=(0,n.c)(),S=(0,n.c)(),O=(0,n.c)(),b=(0,n.c)(),A=(0,n.c)(),x=(0,n.c)(),w=(0,n.c)(),P=(0,o.c)(),R=(0,n.c)(),C=(0,n.c)(),D=(0,n.c)(),L=(0,n.c)(),M=(0,n.c)(),N=(0,a.Ue)();(0,s.s)(R,0,1,0),(0,s.b)(S,t[1],t[0]),(0,s.n)(S,S),c?((0,s.a)(P,t[0],p),(0,s.n)(O,P)):(0,s.s)(O,0,0,1),E(S,O,R,R,A,O,I),(0,s.c)(b,O),(0,s.c)(L,A);for(let n=0;n<i.length;n++)(0,s.g)(x,A,i[n][0]),(0,s.g)(P,O,i[n][2]),(0,s.a)(x,x,P),(0,s.a)(x,x,t[0]),f[_++]=x[0],f[_++]=x[1],f[_++]=x[2];g[T++]=-S[0],g[T++]=-S[1],g[T++]=-S[2];for(let s=0;s<r.length;s++)v.push(r[s][0]>0?r[s][0]:-r[s][0]-1+i.length),v.push(r[s][1]>0?r[s][1]:-r[s][1]-1+i.length),v.push(r[s][2]>0?r[s][2]:-r[s][2]-1+i.length),m.push(0),m.push(0),m.push(0);let j=i.length;const H=i.length-1;for(let n=0;n<t.length;n++){let i=!1;n>0&&((0,s.c)(y,S),n<t.length-1?((0,s.b)(S,t[n+1],t[n]),(0,s.n)(S,S)):i=!0,(0,s.a)(C,y,S),(0,s.n)(C,C),(0,s.a)(D,t[n-1],b),(0,a.Yq)(t[n],C,N),(0,a.BR)(N,(0,l.re)(D,y),P)?((0,s.b)(P,P,t[n]),(0,s.n)(O,P),(0,s.f)(A,C,O),(0,s.n)(A,A)):E(C,b,L,R,A,O,I),(0,s.c)(b,O),(0,s.c)(L,A)),c&&((0,s.a)(P,t[n],p),(0,s.n)(M,P));for(let r=0;r<d;r++)if((0,s.g)(x,A,e[r][0]),(0,s.g)(P,O,e[r][1]),(0,s.a)(x,x,P),(0,s.n)(w,x),g[T++]=w[0],g[T++]=w[1],g[T++]=w[2],(0,s.a)(x,x,t[n]),f[_++]=x[0],f[_++]=x[1],f[_++]=x[2],!i){const e=(r+1)%d;v.push(j+r),v.push(j+d+r),v.push(j+e),v.push(j+e),v.push(j+d+r),v.push(j+d+e);for(let t=0;t<6;t++){const e=v.length-6;m.push(v[e+t]-H)}}j+=d}const F=t[t.length-1];for(let n=0;n<i.length;n++)(0,s.g)(x,A,i[n][0]),(0,s.g)(P,O,i[n][1]),(0,s.a)(x,x,P),(0,s.a)(x,x,F),f[_++]=x[0],f[_++]=x[1],f[_++]=x[2];const U=T/3;g[T++]=S[0],g[T++]=S[1],g[T++]=S[2];const z=j-d;for(let s=0;s<r.length;s++)v.push(r[s][0]>=0?j+r[s][0]:-r[s][0]-1+z),v.push(r[s][2]>=0?j+r[s][2]:-r[s][2]-1+z),v.push(r[s][1]>=0?j+r[s][1]:-r[s][1]-1+z),m.push(U),m.push(U),m.push(U);const V=[[u.T.POSITION,v],[u.T.NORMAL,m]],W=[[u.T.POSITION,{size:3,data:f,exclusive:!0}],[u.T.NORMAL,{size:3,data:g,exclusive:!0}]];return new h.Z(W,V)}function R(e,t,i){(0,d.hu)(e.length>1,"createPolylineGeometry(): polyline needs at least 2 points"),(0,d.hu)(3===e[0].length,"createPolylineGeometry(): malformed vertex"),(0,d.hu)(null==t||t.length===e.length,"createPolylineGeometry: need same number of points and normals"),(0,d.hu)(null==t||3===t[0].length,"createPolylineGeometry(): malformed normal");const r=new Float64Array(3*e.length),s=new Array(2*(e.length-1));let n=0,o=0;for(let c=0;c<e.length;c++){for(let t=0;t<3;t++)r[n++]=e[c][t];c>0&&(s[o++]=c-1,s[o++]=c)}const a=[],l=[];if(a.push([u.T.POSITION,s]),l.push([u.T.POSITION,{size:3,data:r,exclusive:!0}]),t){const i=new Float32Array(3*t.length);let r=0;for(let s=0;s<e.length;s++)for(let e=0;e<3;e++)i[r++]=t[s][e];a.push([u.T.NORMAL,s]),l.push([u.T.NORMAL,{size:3,data:i,exclusive:!0}])}return i&&(l.push([u.T.COLOR,{size:4,data:i}]),a.push([u.T.COLOR,(0,p.p)(i.length/4)])),new h.Z(l,a,c.MX.Line)}function C(e,t,i,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0;const n=new Array(18),o=[[-t,s,r/2],[i,s,r/2],[0,e+s,r/2],[-t,s,-r/2],[i,s,-r/2],[0,e+s,-r/2]],a=[0,1,2,3,0,2,2,5,3,1,4,5,5,2,1,1,0,3,3,4,1,4,3,5];for(let l=0;l<6;l++)n[3*l]=o[l][0],n[3*l+1]=o[l][1],n[3*l+2]=o[l][2];return new h.Z([[u.T.POSITION,{size:3,data:n,exclusive:!0}]],[[u.T.POSITION,a]])}function D(e,t){const i=e.getMutableAttribute(u.T.POSITION).data;for(let r=0;r<i.length;r+=3){const e=i[r],n=i[r+1],o=i[r+2];(0,s.s)(N,e,n,o),(0,s.m)(N,N,t),i[r]=N[0],i[r+1]=N[1],i[r+2]=N[2]}}function L(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e;const i=e.vertexAttributes,r=i.get(u.T.POSITION).data,s=i.get(u.T.NORMAL).data;if(s){const e=t.getMutableAttribute(u.T.NORMAL).data;for(let t=0;t<s.length;t+=3){const i=s[t+1];e[t+1]=-s[t+2],e[t+2]=i}}if(r){const e=t.getMutableAttribute(u.T.POSITION).data;for(let t=0;t<r.length;t+=3){const i=r[t+1];e[t+1]=-r[t+2],e[t+2]=i}}return t}function M(e,t,i,r,n){return!(Math.abs((0,s.e)(t,e))>n)&&((0,s.f)(i,e,t),(0,s.n)(i,i),(0,s.f)(r,i,e),(0,s.n)(r,r),!0)}function E(e,t,i,r,s,n,o){return M(e,t,s,n,o)||M(e,i,s,n,o)||M(e,r,s,n,o)}const I=.99619469809,N=(0,n.c)()},81268:(e,t,i)=>{i.d(t,{Z8:()=>_,LP:()=>O});var r=i(92026),s=i(14226),n=i(81949),o=i(11186),a=i(71353),l=i(90045),c=i(67077),h=i(40885),p=i(50951),d=i(54463);i(82218);function u(e){return(0,r.pC)(e)&&(0,r.pC)(e.dist)}(0,a.c)();var f=i(76783),g=i(32683);const v=1e-5;class m{constructor(e){this.options=new d.om,this._results=new T,this.transform=new f.yn,this.tolerance=v,this.verticalOffset=null,this._ray=(0,h.Ue)(),this._rayEnd=(0,a.c)(),this._rayBeginTransformed=(0,a.c)(),this._rayEndTransformed=(0,a.c)(),this.viewingMode=e??p.JY.Global}get results(){return this._results}get ray(){return this._ray}get rayBegin(){return this._ray.origin}get rayEnd(){return this._rayEnd}reset(e,t,i){this.resetWithRay((0,h.zk)(e,t,this._ray),i)}resetWithRay(e,t){this.camera=t,e!==this._ray&&(0,h.JG)(e,this._ray),0!==this.options.verticalOffset?this.viewingMode===p.JY.Local?this._ray.origin[2]-=this.options.verticalOffset:this.verticalOffset=this.options.verticalOffset:this.verticalOffset=null,(0,o.a)(this._rayEnd,this._ray.origin,this._ray.direction),this._results.init(this._ray)}intersect(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,t=arguments.length>1?arguments[1]:void 0,i=arguments.length>2?arguments[2]:void 0,s=arguments.length>3?arguments[3]:void 0,n=arguments.length>4?arguments[4]:void 0;this.point=t,this.filterPredicate=s,this.tolerance=i??v;const o=(0,f.W9)(this.verticalOffset);if((0,r.pC)(e)&&e.length>0){const t=n?e=>{n(e)&&this.intersectObject(e)}:e=>{this.intersectObject(e)};for(const i of e){const e=i.getSpatialQueryAccelerator&&i.getSpatialQueryAccelerator();(0,r.pC)(e)?((0,r.pC)(o)?e.forEachAlongRayWithVerticalOffset(this._ray.origin,this._ray.direction,t,o):e.forEachAlongRay(this._ray.origin,this._ray.direction,t),this.options.selectionMode&&this.options.hud&&e.forEachDegenerateObject(t)):i.objects.forAll((e=>t(e)))}}this.sortResults()}intersectObject(e){const t=e.geometryRecords;if(!t)return;const i=e.transformation,s=(0,f.W9)(this.verticalOffset);for(const a of t){const{geometry:t,material:l,instanceParameters:c}=a;if((0,g.PD)(c))continue;const h=t.id;this.transform.setAndInvalidateLazyTransforms(i,a.getShaderTransformation()),(0,o.m)(this._rayBeginTransformed,this.rayBegin,this.transform.inverse),(0,o.m)(this._rayEndTransformed,this.rayEnd,this.transform.inverse);const p=this.transform.transform;(0,r.pC)(s)&&(s.objectTransform=this.transform),l.intersect(t,c,this.transform.transform,this,this._rayBeginTransformed,this._rayEndTransformed,((t,i,s,o,a,l)=>{if(t>=0){if((0,r.pC)(this.filterPredicate)&&!this.filterPredicate(this._ray.origin,this._rayEnd,t))return;const c=o?this._results.hud:this._results,u=o?o=>{const c={object:e,geometryId:h,triangleNr:s,center:(0,r.pC)(l)?[l[0],l[1],l[2]]:null};o.set(d.q7.HUD,c,t,i,n.I,a)}:r=>r.set(d.q7.OBJECT,{object:e,geometryId:h,triangleNr:s},t,i,p,a);if((null==c.min.drapedLayerOrder||a>=c.min.drapedLayerOrder)&&(null==c.min.dist||t<c.min.dist)&&u(c.min),this.options.store!==d.eC.MIN&&(null==c.max.drapedLayerOrder||a<c.max.drapedLayerOrder)&&(null==c.max.dist||t>c.max.dist)&&u(c.max),this.options.store===d.eC.ALL)if(o){const e=new S(this._ray);u(e),this._results.hud.all.push(e)}else{const e=new y(this._ray);u(e),this._results.all.push(e)}}}),a.shaderTransformation)}}sortResults(){(arguments.length>0&&void 0!==arguments[0]?arguments[0]:this._results.all).sort(((e,t)=>e.dist!==t.dist?(0,r.Pt)(e.dist,0)-(0,r.Pt)(t.dist,0):e.drapedLayerOrder!==t.drapedLayerOrder?(0,r.Pt)(e.drapedLayerOrder,Number.MAX_VALUE)-(0,r.Pt)(t.drapedLayerOrder,Number.MAX_VALUE):(0,r.Pt)(t.drapedLayerGraphicOrder,Number.MIN_VALUE)-(0,r.Pt)(e.drapedLayerGraphicOrder,Number.MIN_VALUE)))}}function _(e){return new m(e)}class T{constructor(){this.min=new y((0,h.Ue)()),this.max=new y((0,h.Ue)()),this.hud={min:new S((0,h.Ue)()),max:new S((0,h.Ue)()),all:new Array},this.ground=new y((0,h.Ue)()),this.all=[]}init(e){this.min.init(e),this.max.init(e),this.ground.init(e),this.all.length=0,this.hud.min.init(e),this.hud.max.init(e),this.hud.all.length=0}}class y{constructor(e){this.intersector=d.q7.OBJECT,this.normal=(0,a.c)(),this.transformation=(0,n.c)(),this._ray=(0,h.Ue)(),this.init(e)}get ray(){return this._ray}get distanceInRenderSpace(){return(0,r.pC)(this.dist)?((0,o.g)(b,this.ray.direction,this.dist),(0,o.l)(b)):null}getIntersectionPoint(e){return!!u(this)&&((0,o.g)(b,this.ray.direction,this.dist),(0,o.a)(e,this.ray.origin,b),!0)}getTransformedNormal(e){return(0,o.c)(A,this.normal),A[3]=0,(0,l.t)(A,A,this.transformation),(0,o.c)(e,A),(0,o.n)(e,e)}init(e){this.dist=null,this.target=null,this.drapedLayerOrder=null,this.drapedLayerGraphicOrder=null,this.intersector=d.q7.OBJECT,(0,h.JG)(e,this._ray)}set(e,t,i,l,c,h,p){this.intersector=e,this.dist=i,(0,o.c)(this.normal,(0,r.Pt)(l,a.U)),(0,s.c)(this.transformation,(0,r.Pt)(c,n.I)),this.target=t,this.drapedLayerOrder=h,this.drapedLayerGraphicOrder=p}copy(e){(0,h.JG)(e.ray,this._ray),this.intersector=e.intersector,this.dist=e.dist,this.target=e.target,this.drapedLayerOrder=e.drapedLayerOrder,this.drapedLayerGraphicOrder=e.drapedLayerGraphicOrder,(0,o.c)(this.normal,e.normal),(0,s.c)(this.transformation,e.transformation)}}class S extends y{constructor(){super(...arguments),this.intersector=d.q7.HUD}}function O(e){return new y(e)}const b=(0,a.c)(),A=(0,c.c)()},54463:(e,t,i)=>{var r,s;i.d(t,{eC:()=>s,om:()=>n,q7:()=>r}),function(e){e[e.OBJECT=0]="OBJECT",e[e.HUD=1]="HUD",e[e.TERRAIN=2]="TERRAIN",e[e.OVERLAY=3]="OVERLAY",e[e.I3S=4]="I3S",e[e.PCL=5]="PCL",e[e.LOD=6]="LOD",e[e.VOXEL=7]="VOXEL"}(r||(r={}));class n{constructor(){this.verticalOffset=0,this.selectionMode=!1,this.hud=!0,this.selectOpaqueTerrainOnly=!0,this.invisibleTerrain=!1,this.backfacesTerrain=!0,this.isFiltered=!1,this.store=s.ALL}}!function(e){e[e.MIN=0]="MIN",e[e.MINMAX=1]="MINMAX",e[e.ALL=2]="ALL"}(s||(s={}))},59887:(e,t,i)=>{i.d(t,{T:()=>T});var r=i(92026),s=i(14226),n=i(81949),o=i(11186),a=i(71353),l=i(23470),c=i(80064),h=i(68401),p=i(1395),d=i(79100),u=i(13005),f=i(95439);class g{constructor(){this._disposed=!1}get disposed(){return this._disposed}get shaderTransformation(){return this._shaderTransformation}acquire(e,t,i,r,s,n){this.id=(0,f.D)(),this.geometry=e,this.material=t,this.transformation=i,this.instanceParameters=r,this.origin=s,this._shaderTransformation=n,this._disposed=!1}release(){this._disposed=!1}dispose(){this._disposed=!0}getStaticTransformation(){return this.transformation}getShaderTransformation(){return(0,r.pC)(this._shaderTransformation)?this._shaderTransformation(this.transformation):this.transformation}computeAttachmentOrigin(e){return!!(this.material.computeAttachmentOrigin?this.material.computeAttachmentOrigin(this.geometry,e):this.geometry.computeAttachmentOrigin(e))&&((0,o.m)(e,e,this.getStaticTransformation()),!0)}}g.pool=new u.Z(g);var v=i(47669),m=i(97731),_=i(32683);class T extends p.c{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};super(),this.type=d.U.Object,this._geometryRecords=new Array,this._geometries=new Array,this._objectTransformation=(0,n.c)(),this._bvObjectSpace=new S,this._bvWorldSpace=new S,this._bvDirty=!0,this._hasVolatileTransformation=!1,this._visible=!0,this.castShadow=null==e.castShadow||e.castShadow,this.metadata=e.metadata,this.metadata&&this.metadata.isElevationSource&&(this.metadata.lastValidElevationBB=new y);const{geometries:t,materials:i,transformations:r,origins:s}=e;if(Array.isArray(t)){(0,m.hu)(i.length===t.length,"Object3D: materials don't match geometries"),(0,m.hu)(r.length===t.length,"Object3D: transformations don't match geometries"),this._geometryRecords.length=t.length,this._geometries.length=t.length;for(let e=0;e<t.length;e++)this._geometries[e]=t[e],this._geometryRecords[e]=g.pool.acquire(t[e],i[e],(0,n.b)(r[e]),{highlights:null,occludees:null,visible:this._visible},s&&s[e])}}get geometryRecords(){return this._geometryRecords}get geometries(){return this._geometries}get transformation(){return this._objectTransformation}set transformation(e){(0,s.c)(this._objectTransformation,e),this._invalidateBoundingVolume(),this._emit("objectTransformation",this)}dispose(){this._geometryRecords.length=0,this._geometries.length=0}get parentLayer(){return this._parentLayer}set parentLayer(e){(0,m.hu)(null==this._parentLayer||null==e,"Object3D can only be added to a single Layer"),this._parentLayer=e}addGeometry(e,t,i,s,o){i=i||n.I,this._geometries.push(e);const a=g.pool.acquire(e,t,i,{highlights:null,occludees:null,visible:this._visible},s,o);return this._geometryRecords.push(a),this._hasVolatileTransformation=this._hasVolatileTransformation||(0,r.pC)(a.shaderTransformation),this._emit("objectGeometryAdded",{object:this,record:a}),this._invalidateBoundingVolume(),a}removeGeometry(e){const t=this._geometryRecords.splice(e,1)[0];return this._hasVolatileTransformation=(0,r.pC)(t.shaderTransformation)?this._geometryRecords.some((e=>(0,r.pC)(e.shaderTransformation))):this._hasVolatileTransformation,t.dispose(),this._geometries.splice(e,1),this._emit("objectGeometryRemoved",{object:this,record:t}),this._invalidateBoundingVolume(),t}removeAllGeometries(){for(;this.geometryRecords.length>0;)this.removeGeometry(0)}geometryVertexAttrsUpdated(e){this._emit("vertexAttrsUpdated",{object:this,record:e}),this._invalidateBoundingVolume()}get isVisible(){return this._visible}setVisible(e){if(this._visible!==e){this._visible=e;for(const e of this._geometryRecords)e.instanceParameters.visible=this._visible;this._emit("visibilityChanged",this)}}maskOccludee(){const e=new v.O(h.V_.MaskOccludee);for(const t of this._geometryRecords)t.instanceParameters.occludees=(0,_.lr)(t.instanceParameters.occludees,e);return this._emit("occlusionChanged",this),e}removeOcclude(e){for(const t of this._geometryRecords)t.instanceParameters.occludees=(0,_.U_)(t.instanceParameters.occludees,e);this._emit("occlusionChanged",this)}highlight(){const e=new v.O(h.V_.Highlight);for(const t of this._geometryRecords)t.instanceParameters.highlights=(0,_.lr)(t.instanceParameters.highlights,e);return this._emit("highlightChanged",this),e}removeHighlight(e){for(const t of this._geometryRecords)t.instanceParameters.highlights=(0,_.U_)(t.instanceParameters.highlights,e);this._emit("highlightChanged",this)}getCombinedStaticTransformation(e,t){return(0,s.m)(t,this.transformation,e.getStaticTransformation())}_getCombinedShaderTransformation(e){return(0,s.m)((0,n.c)(),this.transformation,e.getShaderTransformation())}hasVolativeTransformation(){return this._hasVolatileTransformation}get boundingVolumeWorldSpace(){return this._validateBoundingVolume(),this._bvWorldSpace}get boundingVolumeObjectSpace(){return this._validateBoundingVolume(),this._bvObjectSpace}_validateBoundingVolume(){if(!this._bvDirty&&!this._hasVolatileTransformation)return;this._bvObjectSpace.init(),this._bvWorldSpace.init();for(let s=0;s<this._geometryRecords.length;++s){const e=this._geometries[s],t=this._geometryRecords[s],i=e.boundingInfo;(0,r.pC)(i)&&(this._calculateTransformedBoundingVolume(i,this._bvObjectSpace,t.getShaderTransformation()),this._calculateTransformedBoundingVolume(i,this._bvWorldSpace,this._getCombinedShaderTransformation(t)))}(0,o.h)(this._bvObjectSpace.bounds,this._bvObjectSpace.min,this._bvObjectSpace.max,.5),(0,o.h)(this._bvWorldSpace.bounds,this._bvWorldSpace.min,this._bvWorldSpace.max,.5);const e=(0,a.c)(),t=(0,a.c)(),i=(0,c.u1)(this.transformation);for(let s=0;s<this._geometryRecords.length;++s){const n=this._geometries[s].boundingInfo;if((0,r.Wi)(n))continue;const a=this._geometryRecords[s].getShaderTransformation(),l=(0,c.u1)(a);(0,o.m)(e,n.getCenter(),a);const h=(0,o.i)(e,this._bvObjectSpace.bounds),p=n.getBSRadius()*l;this._bvObjectSpace.bounds[3]=Math.max(this._bvObjectSpace.bounds[3],h+p),(0,o.m)(t,e,this.transformation);const d=(0,o.i)(t,this._bvWorldSpace.bounds),u=p*i;this._bvWorldSpace.bounds[3]=Math.max(this._bvWorldSpace.bounds[3],d+u)}this._bvDirty=!1}_calculateTransformedBoundingVolume(e,t,i){const r=e.getBBMin(),s=e.getBBMax(),n=(0,a.a)(r),l=(0,a.a)(s);(0,o.m)(n,n,i),(0,o.m)(l,l,i);for(let o=0;o<3;++o)t.min[o]=Math.min(t.min[o],n[o],l[o]),t.max[o]=Math.max(t.max[o],n[o],l[o]);for(let a=0;a<3;++a){(0,o.c)(n,r),(0,o.c)(l,s),n[a]=s[a],l[a]=r[a],(0,o.m)(n,n,i),(0,o.m)(l,l,i);for(let e=0;e<3;++e)t.min[e]=Math.min(t.min[e],n[e],l[e]),t.max[e]=Math.max(t.max[e],n[e],l[e])}}_invalidateBoundingVolume(){this._bvDirty=!0,(0,r.pC)(this._parentLayer)&&this._parentLayer.notifyObjectBBChanged(this,this._bvWorldSpace.bounds)}_emit(e,t){(0,r.pC)(this._parentLayer)&&this._parentLayer.events.emit(e,t)}get test(){const e=this;return{hasGeometry:t=>e._geometries.includes(t),getGeometryIndex:t=>e._geometries.indexOf(t)}}}class y{constructor(){this.min=(0,a.f)(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this.max=(0,a.f)(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE)}isEmpty(){return this.max[0]<this.min[0]&&this.max[1]<this.min[1]&&this.max[2]<this.min[2]}}class S extends y{constructor(){super(...arguments),this.bounds=(0,l.c)()}init(){(0,o.s)(this.min,Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),(0,o.s)(this.max,-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),(0,l.l)(this.bounds)}}},47669:(e,t,i)=>{i.d(t,{O:()=>s});var r=i(95439);class s{constructor(e){this.channel=e,this.id=(0,r.D)()}}},97882:(e,t,i)=>{i.d(t,{F:()=>d});var r=i(91505),s=i(100),n=i(92026),o=i(27546),a=i(68401),l=i(1395),c=i(79100);const h=["layerObjectAdded","layerObjectRemoved","layerObjectsAdded","layerObjectsRemoved","shaderTransformationChanged","objectTransformation","visibilityChanged","occlusionChanged","highlightChanged","objectGeometryAdded","objectGeometryRemoved","vertexAttrsUpdated"];var p=i(78329);class d extends l.c{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"";super(),this.apiLayerUid=t,this.type=c.U.Layer,this.events=new r.Z,this.isSliceable=!1,this._objects=new o.Z,this._stageHandles=new s.Z,this.apiLayerUid=t,this.isVisible=e?.isVisible??!0,this.isPickable=e?.isPickable??!0,this.updatePolicy=e?.updatePolicy??a.jq.ASYNC}get objects(){return this._objects}destroy(){this.detachStage(),this._stage=null}attachStage(e){this.detachStage(),this._stage=e;for(const t of h)this._stageHandles.add(this.events.on(t,(i=>e.handleEvent(t,i))))}detachStage(){this._stageHandles.removeAll(),this.invalidateSpatialQueryAccelerator()}add(e){this._objects.push(e),e.parentLayer=this,this.events.emit("layerObjectAdded",{layer:this,object:e}),(0,n.pC)(this._octree)&&this._octree.add([e])}remove(e){this._objects.removeUnordered(e)&&(e.parentLayer=null,this.events.emit("layerObjectRemoved",{layer:this,object:e}),(0,n.pC)(this._octree)&&this._octree.remove([e]))}addMany(e){this._objects.pushArray(e);for(const t of e)t.parentLayer=this;this.events.emit("layerObjectsAdded",{layer:this,objects:e}),(0,n.pC)(this._octree)&&this._octree.add(e)}removeMany(e){const t=new Array;if(this._objects.removeUnorderedMany(e,e.length,t),0!==t.length){for(const e of t)e.parentLayer=null;this.events.emit("layerObjectsRemoved",{layer:this,objects:t}),(0,n.pC)(this._octree)&&this._octree.remove(t)}}sync(){(0,n.pC)(this._stage)&&this.updatePolicy!==a.jq.SYNC&&this._stage.syncLayer(this.id)}notifyObjectBBChanged(e,t){(0,n.pC)(this._octree)&&this._octree.update(e,t)}getSpatialQueryAccelerator(){return(0,n.Wi)(this._octree)&&this._objects.length>50&&this._createOctree(),this._octree}shaderTransformationChanged(){this.invalidateSpatialQueryAccelerator(),this.events.emit("shaderTransformationChanged",this)}invalidateSpatialQueryAccelerator(){this._octree=(0,n.SC)(this._octree)}_createOctree(){this._octree=new p.Z((e=>e.boundingVolumeWorldSpace.bounds)),this._octree.add(this._objects.data,this._objects.length)}}},66832:(e,t,i)=>{i.d(t,{E:()=>R});var r=i(93169),s=i(67077),n=i(37081),o=i(68401),a=i(23620),l=i(56529),c=i(78041),h=i(93822),p=i(64226),d=i(22909),u=i(82144),f=i(31132),g=i(7566),v=i(27627),m=i(50411),_=i(25920),T=i(45028),y=i(49800),S=i(36207);class O extends f.A{initializeConfiguration(e,t){t.hasWebGL2Context=e.rctx.type===y.zO.WEBGL2}initializeProgram(e){return new v.$(e.rctx,O.shader.get().build(this.configuration),g.i)}_createPipeline(e,t){const i=this.configuration,r=e===_.A.NONE,s=e===_.A.FrontFace;return(0,S.sm)({blending:i.output!==n.H.Color&&i.output!==n.H.Alpha||!i.transparent?null:r?c.wu:(0,c.j7)(e),culling:(0,S.zp)(i.cullFace),depthTest:{func:(0,c.Bh)(e)},depthWrite:r||s?i.writeDepth&&S.LZ:null,colorWrite:S.BK,stencilWrite:i.hasOccludees?m.s3:null,stencilTest:i.hasOccludees?t?m.eD:m.RY:null,polygonOffset:r||s?i.polygonOffset&&b:(0,c.je)(i.enableOffset)})}initializePipeline(){return this._occludeePipelineState=this._createPipeline(this.configuration.transparencyPassType,!0),this._createPipeline(this.configuration.transparencyPassType,!1)}getPipelineState(e,t){return t?this._occludeePipelineState:super.getPipelineState(e,t)}}O.shader=new u.J(T.C,(()=>i.e(3173).then(i.bind(i,23173))));const b={factor:1,units:1};var A=i(27366),x=i(33559),w=i(8883);class P extends w.W{constructor(){super(...arguments),this.output=n.H.Color,this.cullFace=o.Vr.None,this.hasSlicePlane=!1,this.hasVertexColors=!1,this.transparent=!1,this.polygonOffset=!1,this.enableOffset=!0,this.writeDepth=!0,this.hasOccludees=!1,this.transparencyPassType=_.A.NONE,this.hasMultipassTerrain=!1,this.cullAboveGround=!1,this.objectAndLayerIdColorInstanced=!1}}(0,A._)([(0,x.o)({count:n.H.COUNT})],P.prototype,"output",void 0),(0,A._)([(0,x.o)({count:o.Vr.COUNT})],P.prototype,"cullFace",void 0),(0,A._)([(0,x.o)()],P.prototype,"hasSlicePlane",void 0),(0,A._)([(0,x.o)()],P.prototype,"hasVertexColors",void 0),(0,A._)([(0,x.o)()],P.prototype,"transparent",void 0),(0,A._)([(0,x.o)()],P.prototype,"polygonOffset",void 0),(0,A._)([(0,x.o)()],P.prototype,"enableOffset",void 0),(0,A._)([(0,x.o)()],P.prototype,"writeDepth",void 0),(0,A._)([(0,x.o)()],P.prototype,"hasOccludees",void 0),(0,A._)([(0,x.o)({count:_.A.COUNT})],P.prototype,"transparencyPassType",void 0),(0,A._)([(0,x.o)()],P.prototype,"hasMultipassTerrain",void 0),(0,A._)([(0,x.o)()],P.prototype,"cullAboveGround",void 0),(0,A._)([(0,x.o)()],P.prototype,"objectAndLayerIdColorInstanced",void 0);class R extends l.F5{constructor(e){super(e,new D),this.supportsEdges=!0,this._configuration=new P}getConfiguration(e,t){return this._configuration.output=e,this._configuration.cullFace=this.parameters.cullFace,this._configuration.hasVertexColors=this.parameters.hasVertexColors,this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.transparent=this.parameters.transparent,this._configuration.polygonOffset=this.parameters.polygonOffset,this._configuration.writeDepth=this.parameters.writeDepth,this._configuration.hasOccludees=this.parameters.hasOccludees,this._configuration.transparencyPassType=t.transparencyPassType,this._configuration.enableOffset=t.camera.relativeElevation<c.ve,this._configuration.hasMultipassTerrain=t.multipassTerrain.enabled,this._configuration.cullAboveGround=t.multipassTerrain.cullAboveGround,this._configuration}intersect(e,t,i,r,s,n,o){(0,d.Bw)(e,t,r,s,n,void 0,o)}requiresSlot(e,t){return!!(t===n.H.Color||t===n.H.Alpha||t===n.H.Highlight||t===n.H.Depth&&this.parameters.writeLinearDepth||t===n.H.ObjectAndLayerIdColor)&&(e===h.r.DRAPED_MATERIAL||(t===n.H.Highlight?e===h.r.OPAQUE_MATERIAL:e===(this.parameters.transparent?this.parameters.writeDepth?h.r.TRANSPARENT_MATERIAL:h.r.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL:h.r.OPAQUE_MATERIAL)))}createGLMaterial(e){return new C(e)}createBufferWriter(){return new p.G_((0,r.Z)("enable-feature:objectAndLayerId-rendering")?p.ck:p.IM)}}class C extends a.Z{_updateOccludeeState(e){e.hasOccludees!==this._material.parameters.hasOccludees&&this._material.setParameters({hasOccludees:e.hasOccludees})}beginSlot(e){return this._output!==n.H.Color&&this._output!==n.H.Alpha||this._updateOccludeeState(e),this.ensureTechnique(O,e)}}class D extends l.Mt{constructor(){super(...arguments),this.color=s.Z,this.transparent=!1,this.writeDepth=!0,this.writeLinearDepth=!1,this.hasVertexColors=!1,this.polygonOffset=!1,this.hasSlicePlane=!1,this.cullFace=o.Vr.None,this.hasOccludees=!1}}},24231:(e,t,i)=>{i.d(t,{Y:()=>V});var r=i(32718),s=i(92026),n=i(17842),o=i(88396),a=i(11186),l=i(71353),c=i(67077),h=i(95773),p=i(85981),d=i(55652),u=i(25158),f=i(37081),g=i(81955),v=i(23620),m=i(56529),_=i(93822),T=i(97731),y=i(4760),S=i(33236),O=i(64226),b=i(22909),A=i(32683),x=i(82144),w=i(31132),P=i(7566),R=i(27627),C=i(50411),D=i(99337),L=i(49800),M=i(8548),E=i(36207);class I extends w.A{get _stippleEnabled(){return this.configuration.stippleEnabled&&this.configuration.output!==f.H.Highlight}initializeConfiguration(e,t){t.hasWebGL2Context=e.rctx.type===L.zO.WEBGL2}initializeProgram(e){return new R.$(e.rctx,I.shader.get().build(this.configuration),P.i)}initializePipeline(){const e=this.configuration,t=(0,E.wK)(M.zi.SRC_ALPHA,M.zi.ONE,M.zi.ONE_MINUS_SRC_ALPHA,M.zi.ONE_MINUS_SRC_ALPHA),i=function(t){let i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;return(0,E.sm)({blending:i,depthTest:C.JN,depthWrite:r,colorWrite:E.BK,stencilWrite:e.hasOccludees?C.s3:null,stencilTest:e.hasOccludees?t?C.eD:C.RY:null})};return e.output===f.H.Color?(this._occludeePipelineState=i(!0,e.transparent||this._stippleEnabled?t:null,E.LZ),i(!1,e.transparent||this._stippleEnabled?t:null,E.LZ)):i(!1)}get primitiveType(){return M.MX.LINES}getPipelineState(e,t){return t?this._occludeePipelineState:super.getPipelineState(e,t)}}I.shader=new x.J(D.N,(()=>i.e(8569).then(i.bind(i,78569))));var N,j,H=i(27366),F=i(33559),U=i(8883);class z extends U.W{constructor(){super(...arguments),this.output=f.H.Color,this.hasSlicePlane=!1,this.hasVertexColors=!1,this.transparent=!1,this.draped=!1,this.stippleEnabled=!1,this.stippleOffColorEnabled=!1,this.stipplePreferContinuous=!0,this.hasOccludees=!1}}(0,H._)([(0,F.o)({count:f.H.COUNT})],z.prototype,"output",void 0),(0,H._)([(0,F.o)()],z.prototype,"hasSlicePlane",void 0),(0,H._)([(0,F.o)()],z.prototype,"hasVertexColors",void 0),(0,H._)([(0,F.o)()],z.prototype,"transparent",void 0),(0,H._)([(0,F.o)()],z.prototype,"draped",void 0),(0,H._)([(0,F.o)()],z.prototype,"stippleEnabled",void 0),(0,H._)([(0,F.o)()],z.prototype,"stippleOffColorEnabled",void 0),(0,H._)([(0,F.o)()],z.prototype,"stipplePreferContinuous",void 0),(0,H._)([(0,F.o)()],z.prototype,"hasOccludees",void 0),(0,H._)([(0,F.o)({constValue:!1})],z.prototype,"stippleRequiresClamp",void 0),(0,H._)([(0,F.o)({constValue:!1})],z.prototype,"stippleScaleWithLineWidth",void 0),(0,H._)([(0,F.o)({constValue:!1})],z.prototype,"stippleRequiresStretchMeasure",void 0),(j=N||(N={}))[j.START=0]="START",j[j.END=1]="END";class V extends m.F5{constructor(e){super(e,new G),this._configuration=new z}getConfiguration(e,t){this._configuration.output=e,this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.hasVertexColors=this.parameters.hasVertexColors,this._configuration.transparent=this.parameters.color[3]<1||this.parameters.width<1,this._configuration.draped=t.slot===_.r.DRAPED_MATERIAL;const i=(0,s.pC)(this.parameters.stipplePattern);return this._configuration.stippleEnabled=i,this._configuration.stippleOffColorEnabled=i&&(0,s.pC)(this.parameters.stippleOffColor),this._configuration.hasOccludees=this.parameters.hasOccludees,this._configuration.stipplePreferContinuous=this.parameters.stipplePreferContinuous,this._configuration}intersect(e,t,i,r,n,o,a,l,c){(0,s.pC)(c)?(0,b.TT)(e,r,c,o,1,a):this._intersectLineGeometry(e,t,i,r,a)}_intersectLineGeometry(e,t,i,s,n){if(!s.options.selectionMode||(0,A.PD)(t))return;if(!(0,T.kG)(i))return void r.Z.getLogger("esri.views.3d.webgl-engine.materials.NativeLineMaterial").error("intersection assumes a translation-only matrix");const l=e.vertexAttributes.get(y.T.POSITION).data,c=s.camera,u=te;(0,o.c)(u,s.point);(0,a.s)(ie[0],u[0]-2,u[1]+2,0),(0,a.s)(ie[1],u[0]+2,u[1]+2,0),(0,a.s)(ie[2],u[0]+2,u[1]-2,0),(0,a.s)(ie[3],u[0]-2,u[1]-2,0);for(let r=0;r<4;r++)if(!c.unprojectFromRenderScreen(ie[r],re[r]))return;(0,d.zk)(c.eye,re[0],re[1],se),(0,d.zk)(c.eye,re[1],re[2],ne),(0,d.zk)(c.eye,re[2],re[3],oe),(0,d.zk)(c.eye,re[3],re[0],ae);let f=Number.MAX_VALUE,g=0;for(let r=0;r<l.length-5;r+=3){if(k[0]=l[r]+i[12],k[1]=l[r+1]+i[13],k[2]=l[r+2]+i[14],J[0]=l[r+3]+i[12],J[1]=l[r+4]+i[13],J[2]=l[r+5]+i[14],(0,d.jH)(se,k)<0&&(0,d.jH)(se,J)<0||(0,d.jH)(ne,k)<0&&(0,d.jH)(ne,J)<0||(0,d.jH)(oe,k)<0&&(0,d.jH)(oe,J)<0||(0,d.jH)(ae,k)<0&&(0,d.jH)(ae,J)<0)continue;if(c.projectToRenderScreen(k,q),c.projectToRenderScreen(J,X),q[2]<0&&X[2]>0){(0,a.b)($,k,J);const e=c.frustum,t=-(0,d.jH)(e[h.Nu.NEAR],k)/(0,a.e)($,(0,d.mJ)(e[h.Nu.NEAR]));(0,a.g)($,$,t),(0,a.a)(k,k,$),c.projectToRenderScreen(k,q)}else if(q[2]>0&&X[2]<0){(0,a.b)($,J,k);const e=c.frustum,t=-(0,d.jH)(e[h.Nu.NEAR],J)/(0,a.e)($,(0,d.mJ)(e[h.Nu.NEAR]));(0,a.g)($,$,t),(0,a.a)(J,J,$),c.projectToRenderScreen(J,X)}else if(q[2]<0&&X[2]<0)continue;q[2]=0,X[2]=0;const e=(0,p.Jk)((0,p.zk)(q,X,K),u);e<f&&(f=e,(0,a.c)(Y,k),(0,a.c)(Q,J),g=r/3)}const v=s.rayBegin,m=s.rayEnd;if(f<4){let e=Number.MAX_VALUE;if((0,p.AR)((0,p.zk)(Y,Q,K),(0,p.zk)(v,m,ee),Z)){(0,a.b)(Z,Z,v);const t=(0,a.l)(Z);(0,a.g)(Z,Z,1/t),e=t/(0,a.i)(v,m)}n(e,Z,g,!1)}}computeAttachmentOrigin(e,t){const i=e.vertexAttributes;if(!i)return!1;const r=i.get(y.T.POSITION);return(0,g.qZ)(r,null,!1,t)}requiresSlot(e,t){return!(t!==f.H.Color&&t!==f.H.Highlight&&t!==f.H.ObjectAndLayerIdColor||e!==_.r.OPAQUE_MATERIAL&&e!==_.r.DRAPED_MATERIAL)}createGLMaterial(e){return new W(e)}createBufferWriter(){const e=this.parameters.hasVertexColors?O.IM:O.wp;return(0,s.Wi)(this.parameters.stipplePattern)?new O.G_(e):new B(e.clone().vec3f(y.T.AUXPOS1).vec2f(y.T.UV0))}}class W extends v.Z{constructor(){super(...arguments),this._stipplePattern=null}dispose(){super.dispose(),this._stippleTextureRepository.release(this._stipplePattern),this._stipplePattern=null}_updateOccludeeState(e){e.hasOccludees!==this._material.parameters.hasOccludees&&this._material.setParameters({hasOccludees:e.hasOccludees})}beginSlot(e){this._output===f.H.Color&&this._updateOccludeeState(e);const t=this._material.parameters.stipplePattern;return this._stipplePattern!==t&&(this._material.setParameters(this._stippleTextureRepository.swap(this._stipplePattern,t)),this._stipplePattern=t),this.ensureTechnique(I,e)}}class B{constructor(e){this.vertexBufferLayout=e}allocate(e){return this.vertexBufferLayout.createBuffer(e)}elementCount(e){return e.indices.get(y.T.POSITION).length}write(e,t,i,r,s){(0,S.NK)(i,this.vertexBufferLayout,e,t,r,s),this._writeAuxpos1(e,i,r,s),this._writeUV0(e,i,r,s)}_writeAuxpos1(e,t,i,r){const s=i.getField(y.T.AUXPOS1,u.ct),n=t.indices.get(y.T.POSITION),o=t.vertexAttributes.get(y.T.POSITION).data,a=e,l=s.typedBufferStride,c=s.typedBuffer;r*=l;for(let h=0;h<n.length-1;h+=2)for(const e of[1,0]){const t=3*n[h+e],i=o[t],s=o[t+1],p=o[t+2],d=a[0]*i+a[4]*s+a[8]*p+a[12],u=a[1]*i+a[5]*s+a[9]*p+a[13],f=a[2]*i+a[6]*s+a[10]*p+a[14];c[r]=d,c[r+1]=u,c[r+2]=f,r+=l}}_writeUV0(e,t,i,r){const s=i.getField(y.T.UV0,u.Eu),n=t.indices.get(y.T.POSITION),o=t.vertexAttributes.get(y.T.POSITION).data,l=t.vertexAttributes.get(y.T.DISTANCETOSTART)?.data,c=s.typedBufferStride,h=s.typedBuffer;let p=0;h[r*=c]=N.START,h[r+1]=p,r+=c;const d=3*n[0],f=(0,a.s)(k,o[d],o[d+1],o[d+2]);e&&(0,a.m)(f,f,e);const g=J,v=n.length-1;let m=1;const _=l?(e,t,i)=>p=l[i]:(e,t,i)=>p+=(0,a.i)(e,t);for(let u=1;u<v;u+=2){const t=3*n[u];(0,a.s)(g,o[t],o[t+1],o[t+2]),e&&(0,a.m)(g,g,e),_(f,g,m++);for(let e=0;e<2;++e)h[r]=1-e,h[r+1]=p,r+=c;(0,a.c)(f,g)}const T=3*n[v];(0,a.s)(g,o[T],o[T+1],o[T+2]),e&&(0,a.m)(g,g,e),_(f,g,m),h[r]=N.END,h[r+1]=p}}class G extends m.Mt{constructor(){super(...arguments),this.color=c.O,this.hasVertexColors=!1,this.hasSlicePlane=!1,this.width=1,this.stipplePreferContinuous=!0,this.hasOccludees=!1,this.stippleTexture=null}}const k=(0,l.c)(),J=(0,l.c)(),$=(0,l.c)(),Z=(0,l.c)(),q=(0,n.J$)(),X=(0,n.J$)(),Y=(0,l.c)(),Q=(0,l.c)(),K=(0,p.Ue)(),ee=(0,p.Ue)(),te=(0,l.c)(),ie=[(0,n.J$)(),(0,n.J$)(),(0,n.J$)(),(0,n.J$)()],re=[(0,l.c)(),(0,l.c)(),(0,l.c)(),(0,l.c)()],se=(0,d.Ue)(),ne=(0,d.Ue)(),oe=(0,d.Ue)(),ae=(0,d.Ue)()},58901:(e,t,i)=>{i.d(t,{U:()=>V});var r=i(93169),s=i(32718),n=i(16889),o=i(92026),a=i(17842),l=i(88396),c=i(11186),h=i(71353),p=i(67077),d=i(95773),u=i(85981),f=i(55652),g=i(55158),v=i(37081),m=i(81955),_=i(23620),T=i(56529),y=i(93822),S=i(97731),O=i(4760),b=i(65964),A=i(32683),x=i(33720),w=i(98186),P=i(82144),R=i(31132),C=i(78041),D=i(27627),L=i(50411),M=i(25920),E=i(8548),I=i(36207);const N=new Map([[O.T.POSITION,0],[O.T.SUBDIVISIONFACTOR,1],[O.T.UV0,2],[O.T.AUXPOS1,3],[O.T.AUXPOS2,4],[O.T.COLOR,5],[O.T.COLORFEATUREATTRIBUTE,5],[O.T.SIZE,6],[O.T.SIZEFEATUREATTRIBUTE,6],[O.T.OPACITYFEATUREATTRIBUTE,7],[O.T.OBJECTANDLAYERIDCOLOR,8]]);class j extends R.A{initializeProgram(e){return new D.$(e.rctx,j.shader.get().build(this.configuration),N)}_makePipelineState(e,t){const i=this.configuration,r=e===M.A.NONE,s=e===M.A.FrontFace;return(0,I.sm)({blending:i.output===v.H.Color||i.output===v.H.Alpha?r?C.wu:(0,C.j7)(e):null,depthTest:{func:(0,C.Bh)(e)},depthWrite:r?i.writeDepth&&I.LZ:(0,C.K5)(e),colorWrite:I.BK,stencilWrite:i.hasOccludees?L.s3:null,stencilTest:i.hasOccludees?t?L.eD:L.RY:null,polygonOffset:r||s?i.hasPolygonOffset&&H:C.E0})}initializePipeline(){const e=this.configuration;if(e.occluder){const t=e.hasPolygonOffset&&H;this._occluderPipelineTransparent=(0,I.sm)({blending:C.wu,polygonOffset:t,depthTest:L.zV,depthWrite:null,colorWrite:I.BK,stencilWrite:null,stencilTest:L.YD}),this._occluderPipelineOpaque=(0,I.sm)({blending:C.wu,polygonOffset:t,depthTest:L.zV,depthWrite:null,colorWrite:I.BK,stencilWrite:L.P7,stencilTest:L.ii}),this._occluderPipelineMaskWrite=(0,I.sm)({blending:null,polygonOffset:t,depthTest:L.JN,depthWrite:null,colorWrite:null,stencilWrite:L.s3,stencilTest:L.eD})}return this._occludeePipelineState=this._makePipelineState(this.configuration.transparencyPassType,!0),this._makePipelineState(this.configuration.transparencyPassType,!1)}get primitiveType(){return this.configuration.wireframe?E.MX.LINES:E.MX.TRIANGLE_STRIP}getPipelineState(e,t){return t?this._occludeePipelineState:this.configuration.occluder?e===y.r.TRANSPARENT_OCCLUDER_MATERIAL?this._occluderPipelineTransparent:e===y.r.OCCLUDER_MATERIAL?this._occluderPipelineOpaque:this._occluderPipelineMaskWrite:super.getPipelineState(e,t)}}j.shader=new P.J(w.R,(()=>i.e(6279).then(i.bind(i,56279))));const H={factor:0,units:-4};var F,U,z=i(737);(U=F||(F={}))[U.LEFT_JOIN_START=-2]="LEFT_JOIN_START",U[U.LEFT_JOIN_END=-1]="LEFT_JOIN_END",U[U.LEFT_CAP_START=-4]="LEFT_CAP_START",U[U.LEFT_CAP_END=-5]="LEFT_CAP_END",U[U.RIGHT_JOIN_START=2]="RIGHT_JOIN_START",U[U.RIGHT_JOIN_END=1]="RIGHT_JOIN_END",U[U.RIGHT_CAP_START=4]="RIGHT_CAP_START",U[U.RIGHT_CAP_END=5]="RIGHT_CAP_END";class V extends T.F5{constructor(e){super(e,new B),this._configuration=new z.G,this._vertexAttributeLocations=N,this._layout=this.createLayout()}isClosed(e,t){return $(this.parameters,e,t)}getConfiguration(e,t){this._configuration.output=e,this._configuration.draped=t.slot===y.r.DRAPED_MATERIAL;const i=(0,o.pC)(this.parameters.stipplePattern)&&e!==v.H.Highlight;return this._configuration.stippleEnabled=i,this._configuration.stippleOffColorEnabled=i&&(0,o.pC)(this.parameters.stippleOffColor),this._configuration.stippleScaleWithLineWidth=i&&this.parameters.stippleScaleWithLineWidth,this._configuration.stipplePreferContinuous=i&&this.parameters.stipplePreferContinuous,this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.hasOccludees=this.parameters.hasOccludees,this._configuration.roundJoins="round"===this.parameters.join,this._configuration.capType=this.parameters.cap,this._configuration.applyMarkerOffset=!!(0,o.pC)(this.parameters.markerParameters)&&function(e){return e.anchor===x.i5.Tip&&e.hideOnShortSegments&&"begin-end"===e.placement&&e.worldSpace}(this.parameters.markerParameters),this._configuration.hasPolygonOffset=this.parameters.hasPolygonOffset,this._configuration.writeDepth=this.parameters.writeDepth,this._configuration.vvColor=this.parameters.vvColorEnabled,this._configuration.vvOpacity=this.parameters.vvOpacityEnabled,this._configuration.vvSize=this.parameters.vvSizeEnabled,this._configuration.innerColorEnabled=this.parameters.innerWidth>0&&(0,o.pC)(this.parameters.innerColor),this._configuration.falloffEnabled=this.parameters.falloff>0,this._configuration.occluder=this.parameters.renderOccluded===T.yD.OccludeAndTransparentStencil,this._configuration.transparencyPassType=t.transparencyPassType,this._configuration.hasMultipassTerrain=t.multipassTerrain.enabled,this._configuration.cullAboveGround=t.multipassTerrain.cullAboveGround,this._configuration.wireframe=this.parameters.wireframe,this._configuration}intersect(e,t,i,r,s,n,a,l,c){(0,o.pC)(c)?this._intersectDrapedLineGeometry(e,r,c,n,a):this._intersectLineGeometry(e,t,i,r,a)}_intersectDrapedLineGeometry(e,t,i,r,s){if(!t.options.selectionMode)return;const o=e.vertexAttributes.get(O.T.POSITION).data,a=e.vertexAttributes.get(O.T.SIZE);let l=this.parameters.width;if(this.parameters.vvSizeEnabled){const t=e.vertexAttributes.get(O.T.SIZEFEATUREATTRIBUTE).data[0];l*=(0,n.uZ)(this.parameters.vvSizeOffset[0]+t*this.parameters.vvSizeFactor[0],this.parameters.vvSizeMinSize[0],this.parameters.vvSizeMaxSize[0])}else a&&(l*=a.data[0]);const c=r[0],h=r[1],p=(l/2+4)*e.screenToWorldRatio;let d=Number.MAX_VALUE,u=0;for(let f=0;f<o.length-5;f+=3){const e=o[f],t=o[f+1],i=c-e,r=h-t,s=o[f+3]-e,a=o[f+4]-t,l=(0,n.uZ)((s*i+a*r)/(s*s+a*a),0,1),p=s*l-i,g=a*l-r,v=p*p+g*g;v<d&&(d=v,u=f/3)}d<p*p&&s(i.dist,i.normal,u,!1)}_intersectLineGeometry(e,t,i,r,o){if(!r.options.selectionMode||(0,A.PD)(t))return;if(!(0,S.kG)(i))return void s.Z.getLogger("esri.views.3d.webgl-engine.materials.RibbonLineMaterial").error("intersection assumes a translation-only matrix");const a=e.vertexAttributes,h=a.get(O.T.POSITION).data;let p=this.parameters.width;if(this.parameters.vvSizeEnabled){const e=a.get(O.T.SIZEFEATUREATTRIBUTE).data[0];p*=(0,n.uZ)(this.parameters.vvSizeOffset[0]+e*this.parameters.vvSizeFactor[0],this.parameters.vvSizeMinSize[0],this.parameters.vvSizeMaxSize[0])}else a.has(O.T.SIZE)&&(p*=a.get(O.T.SIZE).data[0]);const g=r.camera,v=Q;(0,l.c)(v,r.point);const m=p*g.pixelRatio/2+4*g.pixelRatio;(0,c.s)(le[0],v[0]-m,v[1]+m,0),(0,c.s)(le[1],v[0]+m,v[1]+m,0),(0,c.s)(le[2],v[0]+m,v[1]-m,0),(0,c.s)(le[3],v[0]-m,v[1]-m,0);for(let s=0;s<4;s++)if(!g.unprojectFromRenderScreen(le[s],ce[s]))return;(0,f.zk)(g.eye,ce[0],ce[1],he),(0,f.zk)(g.eye,ce[1],ce[2],pe),(0,f.zk)(g.eye,ce[2],ce[3],de),(0,f.zk)(g.eye,ce[3],ce[0],ue);let _=Number.MAX_VALUE,T=0;const y=J(this.parameters,a,e.indices)?h.length-2:h.length-5;for(let s=0;s<y;s+=3){Z[0]=h[s]+i[12],Z[1]=h[s+1]+i[13],Z[2]=h[s+2]+i[14];const e=(s+3)%h.length;if(q[0]=h[e]+i[12],q[1]=h[e+1]+i[13],q[2]=h[e+2]+i[14],(0,f.jH)(he,Z)<0&&(0,f.jH)(he,q)<0||(0,f.jH)(pe,Z)<0&&(0,f.jH)(pe,q)<0||(0,f.jH)(de,Z)<0&&(0,f.jH)(de,q)<0||(0,f.jH)(ue,Z)<0&&(0,f.jH)(ue,q)<0)continue;if(g.projectToRenderScreen(Z,K),g.projectToRenderScreen(q,ee),K[2]<0&&ee[2]>0){(0,c.b)(X,Z,q);const e=g.frustum,t=-(0,f.jH)(e[d.Nu.NEAR],Z)/(0,c.e)(X,(0,f.mJ)(e[d.Nu.NEAR]));(0,c.g)(X,X,t),(0,c.a)(Z,Z,X),g.projectToRenderScreen(Z,K)}else if(K[2]>0&&ee[2]<0){(0,c.b)(X,q,Z);const e=g.frustum,t=-(0,f.jH)(e[d.Nu.NEAR],q)/(0,c.e)(X,(0,f.mJ)(e[d.Nu.NEAR]));(0,c.g)(X,X,t),(0,c.a)(q,q,X),g.projectToRenderScreen(q,ee)}else if(K[2]<0&&ee[2]<0)continue;K[2]=0,ee[2]=0;const t=(0,u.Jk)((0,u.zk)(K,ee,re),v);t<_&&(_=t,(0,c.c)(te,Z),(0,c.c)(ie,q),T=s/3)}const b=r.rayBegin,x=r.rayEnd;if(_<m*m){let e=Number.MAX_VALUE;if((0,u.AR)((0,u.zk)(te,ie,re),(0,u.zk)(b,x,se),Y)){(0,c.b)(Y,Y,b);const t=(0,c.l)(Y);(0,c.g)(Y,Y,1/t),e=t/(0,c.i)(b,x)}o(e,Y,T,!1)}}computeAttachmentOrigin(e,t){const i=e.vertexAttributes;if(!i)return!1;const r=e.indices,s=i.get(O.T.POSITION);return(0,m.qZ)(s,r?r.get(O.T.POSITION):null,r&&J(this.parameters,i,r),t)}createLayout(){const e=(0,g.U$)().vec3f(O.T.POSITION).f32(O.T.SUBDIVISIONFACTOR).vec2f(O.T.UV0).vec3f(O.T.AUXPOS1).vec3f(O.T.AUXPOS2);return this.parameters.vvSizeEnabled?e.f32(O.T.SIZEFEATUREATTRIBUTE):e.f32(O.T.SIZE),this.parameters.vvColorEnabled?e.f32(O.T.COLORFEATUREATTRIBUTE):e.vec4f(O.T.COLOR),this.parameters.vvOpacityEnabled&&e.f32(O.T.OPACITYFEATUREATTRIBUTE),(0,r.Z)("enable-feature:objectAndLayerId-rendering")&&e.vec4u8(O.T.OBJECTANDLAYERIDCOLOR),e}createBufferWriter(){return new G(this._layout,this.parameters)}requiresSlot(e,t){return(t===v.H.Color||t===v.H.Alpha||t===v.H.Highlight||t===v.H.Depth||t===v.H.ObjectAndLayerIdColor)&&(e===y.r.DRAPED_MATERIAL||(this.parameters.renderOccluded===T.yD.OccludeAndTransparentStencil?e===y.r.OPAQUE_MATERIAL||e===y.r.OCCLUDER_MATERIAL||e===y.r.TRANSPARENT_OCCLUDER_MATERIAL:t===v.H.Color||t===v.H.Alpha?e===(this.parameters.writeDepth?y.r.TRANSPARENT_MATERIAL:y.r.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL):e===y.r.OPAQUE_MATERIAL))}createGLMaterial(e){return new W(e)}validateParameters(e){"miter"!==e.join&&(e.miterLimit=0),(0,o.pC)(e.markerParameters)&&(e.markerScale=e.markerParameters.width/e.width)}}class W extends _.Z{constructor(){super(...arguments),this._stipplePattern=null}dispose(){super.dispose(),this._stippleTextureRepository.release(this._stipplePattern),this._stipplePattern=null}_updateOccludeeState(e){e.hasOccludees!==this._material.parameters.hasOccludees&&this._material.setParameters({hasOccludees:e.hasOccludees})}beginSlot(e){this._output!==v.H.Color&&this._output!==v.H.Alpha||this._updateOccludeeState(e);const t=this._material.parameters.stipplePattern;return this._stipplePattern!==t&&(this._material.setParameters(this._stippleTextureRepository.swap(this._stipplePattern,t)),this._stipplePattern=t),this.ensureTechnique(j,e)}}class B extends b.n{constructor(){super(...arguments),this.width=0,this.color=p.O,this.join="miter",this.cap=z.R.BUTT,this.miterLimit=5,this.writeDepth=!0,this.hasPolygonOffset=!1,this.stippleTexture=null,this.stippleScaleWithLineWidth=!1,this.stipplePreferContinuous=!0,this.markerParameters=null,this.markerScale=1,this.hasSlicePlane=!1,this.vvFastUpdate=!1,this.isClosed=!1,this.falloff=0,this.innerWidth=0,this.hasOccludees=!1,this.wireframe=!1}}class G{constructor(e,t){this._parameters=t,this.numJoinSubdivisions=0,this.vertexBufferLayout=e;const i=t.stipplePattern?1:0;switch(this._parameters.join){case"miter":case"bevel":this.numJoinSubdivisions=i;break;case"round":this.numJoinSubdivisions=w.N+i}}_isClosed(e){return J(this._parameters,e.vertexAttributes,e.indices)}allocate(e){return this.vertexBufferLayout.createBuffer(e)}elementCount(e){const t=e.indices.get(O.T.POSITION).length/2+1,i=this._isClosed(e);let r=i?2:4;return r+=((i?t:t-1)-(i?0:1))*(2*this.numJoinSubdivisions+4),r+=2,this._parameters.wireframe&&(r=2+4*(r-2)),r}write(e,t,i,s,n){const a=ne,l=oe,h=ae,p=i.vertexAttributes.get(O.T.POSITION).data,d=i.indices&&i.indices.get(O.T.POSITION),u=i.vertexAttributes.get(O.T.DISTANCETOSTART)?.data;d&&d.length!==2*(p.length/3-1)&&console.warn("RibbonLineMaterial does not support indices");let f=1,g=0;this._parameters.vvSizeEnabled?g=i.vertexAttributes.get(O.T.SIZEFEATUREATTRIBUTE).data[0]:i.vertexAttributes.has(O.T.SIZE)&&(f=i.vertexAttributes.get(O.T.SIZE).data[0]);let v=[1,1,1,1],m=0;this._parameters.vvColorEnabled?m=i.vertexAttributes.get(O.T.COLORFEATUREATTRIBUTE).data[0]:i.vertexAttributes.has(O.T.COLOR)&&(v=i.vertexAttributes.get(O.T.COLOR).data);let _=null;(0,r.Z)("enable-feature:objectAndLayerId-rendering")&&(_=i.objectAndLayerIdColor);let T=0;this._parameters.vvOpacityEnabled&&(T=i.vertexAttributes.get(O.T.OPACITYFEATUREATTRIBUTE).data[0]);const y=p.length/3,S=new Float32Array(s.buffer),b=(0,r.Z)("enable-feature:objectAndLayerId-rendering")?new Uint8Array(s.buffer):null,A=this.vertexBufferLayout.stride/4;let x=n*A;const w=x;let P=0;const R=u?(e,t,i)=>P=u[i]:(e,t,i)=>P+=(0,c.i)(e,t),C=(e,t,i,s,n,a,l)=>{if(S[x++]=t[0],S[x++]=t[1],S[x++]=t[2],S[x++]=s,S[x++]=l,S[x++]=n,S[x++]=e[0],S[x++]=e[1],S[x++]=e[2],S[x++]=i[0],S[x++]=i[1],S[x++]=i[2],this._parameters.vvSizeEnabled?S[x++]=g:S[x++]=f,this._parameters.vvColorEnabled)S[x++]=m;else{const e=Math.min(4*a,v.length-4);S[x++]=v[e+0],S[x++]=v[e+1],S[x++]=v[e+2],S[x++]=v[e+3]}this._parameters.vvOpacityEnabled&&(S[x++]=T),(0,r.Z)("enable-feature:objectAndLayerId-rendering")&&((0,o.pC)(_)&&(b[4*x+0]=_[0],b[4*x+1]=_[1],b[4*x+2]=_[2],b[4*x+3]=_[3]),x++)};x+=A,(0,c.s)(l,p[0],p[1],p[2]),e&&(0,c.m)(l,l,e);const D=this._isClosed(i);if(D){const t=p.length-3;(0,c.s)(a,p[t],p[t+1],p[t+2]),e&&(0,c.m)(a,a,e)}else(0,c.s)(h,p[3],p[4],p[5]),e&&(0,c.m)(h,h,e),C(l,l,h,1,F.LEFT_CAP_START,0,0),C(l,l,h,1,F.RIGHT_CAP_START,0,0),(0,c.c)(a,l),(0,c.c)(l,h);const L=D?0:1,M=D?y:y-1;for(let r=L;r<M;r++){const t=(r+1)%y*3;(0,c.s)(h,p[t+0],p[t+1],p[t+2]),e&&(0,c.m)(h,h,e),R(a,l,r),C(a,l,h,0,F.LEFT_JOIN_END,r,P),C(a,l,h,0,F.RIGHT_JOIN_END,r,P);const i=this.numJoinSubdivisions;for(let e=0;e<i;++e){const t=(e+1)/(i+1);C(a,l,h,t,F.LEFT_JOIN_END,r,P),C(a,l,h,t,F.RIGHT_JOIN_END,r,P)}C(a,l,h,1,F.LEFT_JOIN_START,r,P),C(a,l,h,1,F.RIGHT_JOIN_START,r,P),(0,c.c)(a,l),(0,c.c)(l,h)}D?((0,c.s)(h,p[3],p[4],p[5]),e&&(0,c.m)(h,h,e),P=R(a,l,M),C(a,l,h,0,F.LEFT_JOIN_END,L,P),C(a,l,h,0,F.RIGHT_JOIN_END,L,P)):(P=R(a,l,M),C(a,l,l,0,F.LEFT_CAP_END,M,P),C(a,l,l,0,F.RIGHT_CAP_END,M,P)),k(S,w+A,S,w,A),x=k(S,x-A,S,x,A),this._parameters.wireframe&&this._addWireframeVertices(s,w,x,A)}_addWireframeVertices(e,t,i,r){const s=new Float32Array(e.buffer,i*Float32Array.BYTES_PER_ELEMENT),n=new Float32Array(e.buffer,t*Float32Array.BYTES_PER_ELEMENT,i-t);let o=0;const a=e=>o=k(n,e,s,o,r);for(let l=0;l<n.length-1;l+=2*r)a(l),a(l+2*r),a(l+1*r),a(l+2*r),a(l+1*r),a(l+3*r)}}function k(e,t,i,r,s){for(let n=0;n<s;n++)i[r++]=e[t++];return r}function J(e,t,i){return $(e,t.get(O.T.POSITION).data,i?i.get(O.T.POSITION):null)}function $(e,t,i){return!!e.isClosed&&(i?i.length>2:t.length>6)}const Z=(0,h.c)(),q=(0,h.c)(),X=(0,h.c)(),Y=(0,h.c)(),Q=(0,h.c)(),K=(0,a.J$)(),ee=(0,a.J$)(),te=(0,h.c)(),ie=(0,h.c)(),re=(0,u.Ue)(),se=(0,u.Ue)(),ne=(0,h.c)(),oe=(0,h.c)(),ae=(0,h.c)(),le=[(0,a.J$)(),(0,a.J$)(),(0,a.J$)(),(0,a.J$)()],ce=[(0,h.c)(),(0,h.c)(),(0,h.c)(),(0,h.c)()],he=(0,f.Ue)(),pe=(0,f.Ue)(),de=(0,f.Ue)(),ue=(0,f.Ue)()},82031:(e,t,i)=>{i.d(t,{$A:()=>d,h0:()=>l,it:()=>f,kj:()=>u});var r=i(46228),s=i(92026),n=i(98634),o=i(8548),a=i(51378);class l{constructor(e){this._rctx=e,this._cache=new Map}dispose(){this._cache.forEach((e=>(0,s.M2)(e.stippleTexture))),this._cache.clear()}_acquire(e){if((0,s.Wi)(e))return null;const t=this._patternId(e),i=this._cache.get(t);if(i)return i.refCount++,i;const{encodedData:r,paddedPixels:n}=h(e),l=new c(new a.x(this._rctx,{width:n,height:1,internalFormat:o.VI.RGBA,pixelFormat:o.VI.RGBA,dataType:o.Br.UNSIGNED_BYTE,wrapMode:o.e8.CLAMP_TO_EDGE},r));return this._cache.set(t,l),l}release(e){if((0,s.Wi)(e))return;const t=this._patternId(e),i=this._cache.get(t);i&&(i.refCount--,0===i.refCount&&((0,s.pC)(i.stippleTexture)&&i.stippleTexture.dispose(),this._cache.delete(t)))}swap(e,t){const i=this._acquire(t);return this.release(e),i}_patternId(e){return`${e.pattern.join(",")}-r${e.pixelRatio}`}}class c extends n.K{constructor(e){super(),this.stippleTexture=e,this.refCount=1}}function h(e){const t=p(e),i=1/e.pixelRatio,s=d(e),n=u(e),o=(Math.floor(.5*(n-1))+.5)*i,a=[];let l=1;for(const r of t){for(let e=0;e<r;e++){const t=l*(Math.min(e,r-1-e)+.5)*i/o*.5+.5;a.push(t)}l=-l}const c=Math.round(t[0]/2),h=[...a.slice(c),...a.slice(0,c)],g=s+f,v=new Uint8Array(4*g);let m=4;for(const p of h)(0,r.I)(p,v,m),m+=4;return v.copyWithin(0,m-4,m),v.copyWithin(m,4,8),{encodedData:v,paddedPixels:g}}function p(e){return e.pattern.map((t=>Math.round(t*e.pixelRatio)))}function d(e){if((0,s.Wi)(e))return 1;const t=p(e);return Math.floor(t.reduce(((e,t)=>e+t)))}function u(e){return p(e).reduce(((e,t)=>Math.max(e,t)))}const f=2},64226:(e,t,i)=>{i.d(t,{G_:()=>h,IM:()=>l,W1:()=>a,ck:()=>c,wp:()=>o});var r=i(55158),s=i(4760),n=i(33236);const o=(0,r.U$)().vec3f(s.T.POSITION),a=(0,r.U$)().vec3f(s.T.POSITION).vec2f(s.T.UV0),l=(0,r.U$)().vec3f(s.T.POSITION).vec4u8(s.T.COLOR),c=((0,r.U$)().vec3f(s.T.POSITION).vec4u8(s.T.OBJECTANDLAYERIDCOLOR),(0,r.U$)().vec3f(s.T.POSITION).vec2f(s.T.UV0).vec4u8(s.T.OBJECTANDLAYERIDCOLOR),(0,r.U$)().vec3f(s.T.POSITION).vec4u8(s.T.COLOR).vec4u8(s.T.OBJECTANDLAYERIDCOLOR));class h{constructor(e){this.vertexBufferLayout=e}allocate(e){return this.vertexBufferLayout.createBuffer(e)}elementCount(e){return e.indices.get(s.T.POSITION).length}write(e,t,i,r,s){(0,n.NK)(i,this.vertexBufferLayout,e,t,r,s)}}},33720:(e,t,i)=>{i.d(t,{I9:()=>r,PI:()=>h,i5:()=>s});var r,s,n=i(27366),o=i(37081),a=i(33559),l=i(25920),c=i(8883);!function(e){e[e.Draped=0]="Draped",e[e.Screen=1]="Screen",e[e.World=2]="World",e[e.COUNT=3]="COUNT"}(r||(r={})),function(e){e[e.Center=0]="Center",e[e.Tip=1]="Tip",e[e.COUNT=2]="COUNT"}(s||(s={}));class h extends c.W{constructor(){super(...arguments),this.output=o.H.Color,this.transparencyPassType=l.A.NONE,this.occluder=!1,this.hasSlicePlane=!1,this.writeDepth=!1,this.space=r.Screen,this.hideOnShortSegments=!1,this.hasCap=!1,this.anchor=s.Center,this.hasTip=!1,this.vvSize=!1,this.vvColor=!1,this.vvOpacity=!1,this.hasOccludees=!1,this.hasMultipassTerrain=!1,this.cullAboveGround=!1}}(0,n._)([(0,a.o)({count:o.H.COUNT})],h.prototype,"output",void 0),(0,n._)([(0,a.o)({count:l.A.COUNT})],h.prototype,"transparencyPassType",void 0),(0,n._)([(0,a.o)()],h.prototype,"occluder",void 0),(0,n._)([(0,a.o)()],h.prototype,"hasSlicePlane",void 0),(0,n._)([(0,a.o)()],h.prototype,"writeDepth",void 0),(0,n._)([(0,a.o)({count:r.COUNT})],h.prototype,"space",void 0),(0,n._)([(0,a.o)()],h.prototype,"hideOnShortSegments",void 0),(0,n._)([(0,a.o)()],h.prototype,"hasCap",void 0),(0,n._)([(0,a.o)({count:s.COUNT})],h.prototype,"anchor",void 0),(0,n._)([(0,a.o)()],h.prototype,"hasTip",void 0),(0,n._)([(0,a.o)()],h.prototype,"vvSize",void 0),(0,n._)([(0,a.o)()],h.prototype,"vvColor",void 0),(0,n._)([(0,a.o)()],h.prototype,"vvOpacity",void 0),(0,n._)([(0,a.o)()],h.prototype,"hasOccludees",void 0),(0,n._)([(0,a.o)()],h.prototype,"hasMultipassTerrain",void 0),(0,n._)([(0,a.o)()],h.prototype,"cullAboveGround",void 0),(0,n._)([(0,a.o)({constValue:!0})],h.prototype,"hasVvInstancing",void 0),(0,n._)([(0,a.o)({constValue:!0})],h.prototype,"hasSliceTranslatedView",void 0)},737:(e,t,i)=>{i.d(t,{G:()=>c,R:()=>r});var r,s=i(27366),n=i(37081),o=i(33559),a=i(25920),l=i(8883);!function(e){e[e.BUTT=0]="BUTT",e[e.SQUARE=1]="SQUARE",e[e.ROUND=2]="ROUND",e[e.COUNT=3]="COUNT"}(r||(r={}));class c extends l.W{constructor(){super(...arguments),this.output=n.H.Color,this.capType=r.BUTT,this.transparencyPassType=a.A.NONE,this.occluder=!1,this.hasSlicePlane=!1,this.hasPolygonOffset=!1,this.writeDepth=!1,this.draped=!1,this.stippleEnabled=!1,this.stippleOffColorEnabled=!1,this.stippleScaleWithLineWidth=!1,this.stipplePreferContinuous=!0,this.roundJoins=!1,this.applyMarkerOffset=!1,this.vvSize=!1,this.vvColor=!1,this.vvOpacity=!1,this.falloffEnabled=!1,this.innerColorEnabled=!1,this.hasOccludees=!1,this.hasMultipassTerrain=!1,this.cullAboveGround=!1,this.wireframe=!1,this.objectAndLayerIdColorInstanced=!1}}(0,s._)([(0,o.o)({count:n.H.COUNT})],c.prototype,"output",void 0),(0,s._)([(0,o.o)({count:r.COUNT})],c.prototype,"capType",void 0),(0,s._)([(0,o.o)({count:a.A.COUNT})],c.prototype,"transparencyPassType",void 0),(0,s._)([(0,o.o)()],c.prototype,"occluder",void 0),(0,s._)([(0,o.o)()],c.prototype,"hasSlicePlane",void 0),(0,s._)([(0,o.o)()],c.prototype,"hasPolygonOffset",void 0),(0,s._)([(0,o.o)()],c.prototype,"writeDepth",void 0),(0,s._)([(0,o.o)()],c.prototype,"draped",void 0),(0,s._)([(0,o.o)()],c.prototype,"stippleEnabled",void 0),(0,s._)([(0,o.o)()],c.prototype,"stippleOffColorEnabled",void 0),(0,s._)([(0,o.o)()],c.prototype,"stippleScaleWithLineWidth",void 0),(0,s._)([(0,o.o)()],c.prototype,"stipplePreferContinuous",void 0),(0,s._)([(0,o.o)()],c.prototype,"roundJoins",void 0),(0,s._)([(0,o.o)()],c.prototype,"applyMarkerOffset",void 0),(0,s._)([(0,o.o)()],c.prototype,"vvSize",void 0),(0,s._)([(0,o.o)()],c.prototype,"vvColor",void 0),(0,s._)([(0,o.o)()],c.prototype,"vvOpacity",void 0),(0,s._)([(0,o.o)()],c.prototype,"falloffEnabled",void 0),(0,s._)([(0,o.o)()],c.prototype,"innerColorEnabled",void 0),(0,s._)([(0,o.o)()],c.prototype,"hasOccludees",void 0),(0,s._)([(0,o.o)()],c.prototype,"hasMultipassTerrain",void 0),(0,s._)([(0,o.o)()],c.prototype,"cullAboveGround",void 0),(0,s._)([(0,o.o)()],c.prototype,"wireframe",void 0),(0,s._)([(0,o.o)({constValue:!0})],c.prototype,"stippleRequiresClamp",void 0),(0,s._)([(0,o.o)({constValue:!0})],c.prototype,"stippleRequiresStretchMeasure",void 0),(0,s._)([(0,o.o)({constValue:!0})],c.prototype,"hasVvInstancing",void 0),(0,s._)([(0,o.o)({constValue:!0})],c.prototype,"hasSliceTranslatedView",void 0),(0,s._)([(0,o.o)()],c.prototype,"objectAndLayerIdColorInstanced",void 0)}}]);
//# sourceMappingURL=5579.f3519b5f.chunk.js.map